<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>进程控制相关函数 | wakaka</title><meta name="keywords" content="linux_program"><meta name="author" content="wakaka"><meta name="copyright" content="wakaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="进程进程相关概念解释程序与进程的区别 程序: 死的，存在硬盘上，只占用磁盘空间。 — 剧本 进程：活动。运行在内存中的程序。占用内存、cpu等资源。 — 戏  虚拟内存与物理内存的映射关系 PCB：进程控制块 MMU：内存管理单元，在CPU内部  . src&#x3D;”.&#x2F;DeepinScreenshot_select-area_20200506155851.png” style&#x3D;”zoom:100%;”">
<meta property="og:type" content="article">
<meta property="og:title" content="进程控制相关函数">
<meta property="og:url" content="https://wakaka6.github.io/2022/01/10/process-control/index.html">
<meta property="og:site_name" content="wakaka">
<meta property="og:description" content="进程进程相关概念解释程序与进程的区别 程序: 死的，存在硬盘上，只占用磁盘空间。 — 剧本 进程：活动。运行在内存中的程序。占用内存、cpu等资源。 — 戏  虚拟内存与物理内存的映射关系 PCB：进程控制块 MMU：内存管理单元，在CPU内部  . src&#x3D;”.&#x2F;DeepinScreenshot_select-area_20200506155851.png” style&#x3D;”zoom:100%;”">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wakaka6.github.io/img/page/3.jpg">
<meta property="article:published_time" content="2022-01-10T14:51:42.000Z">
<meta property="article:modified_time" content="2022-04-14T10:05:40.778Z">
<meta property="article:author" content="wakaka">
<meta property="article:tag" content="linux_program">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wakaka6.github.io/img/page/3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wakaka6.github.io/2022/01/10/process-control/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '进程控制相关函数',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-14 18:05:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/page/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wakaka</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">进程控制相关函数</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-10T14:51:42.000Z" title="发表于 2022-01-10 22:51:42">2022-01-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-14T10:05:40.778Z" title="更新于 2022-04-14 18:05:40">2022-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="进程控制相关函数"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="进程相关概念解释"><a href="#进程相关概念解释" class="headerlink" title="进程相关概念解释"></a>进程相关概念解释</h2><h3 id="程序与进程的区别"><a href="#程序与进程的区别" class="headerlink" title="程序与进程的区别"></a>程序与进程的区别</h3><ul>
<li>程序: 死的，存在硬盘上，只占用磁盘空间。 — 剧本</li>
<li>进程：活动。运行在内存中的程序。占用内存、cpu等资源。 — 戏</li>
</ul>
<h3 id="虚拟内存与物理内存的映射关系"><a href="#虚拟内存与物理内存的映射关系" class="headerlink" title="虚拟内存与物理内存的映射关系"></a>虚拟内存与物理内存的映射关系</h3><ul>
<li>PCB：进程控制块</li>
<li>MMU：内存管理单元，在CPU内部</li>
</ul>
<p>. src=”./DeepinScreenshot_select-area_20200506155851.png” style=”zoom:100%;” /&gt;</p>
<p>进入到系统调用实际上就是靠的MMU进行权级切换</p>
<h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB 进程控制块"></a>PCB 进程控制块</h3><blockquote>
<p>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关信息，linux内核的进程块是task_struct结构体</p>
<p><code>/usr/linux-headers-xx.xx.x-x/include/linux/sched.h</code> 文件中可以查看 <code>struct task_struct</code>结构体定义</p>
</blockquote>
<p>其内部成员有很多，重点掌握以下部分即可：</p>
<ul>
<li><p>进程ID：系统中每个进程有唯一的id，在c语言中用pid_t类型表示，其实就是一个非负整数</p>
</li>
<li><p>进程的状态：有初始、就绪、运行、阻塞、挂起、停止等状态</p>
<ul>
<li>其中初始态为进程准备阶段，常与就绪态结合来看</li>
</ul>
  <img src="/2022/01/10/process-control/DeepinScreenshot_select-area_20200506211732.png" class=""></li>
<li><p>进程切换时需要保存和恢复的一些CPU寄存器</p>
</li>
<li><p>描述虚拟地址空间的信息</p>
</li>
<li><p>描述控制终端的信息</p>
</li>
<li><p>当前工作目录</p>
</li>
<li><p>umask掩码</p>
</li>
<li><p>文件描述符表：包含很多指向file结构体的指针</p>
</li>
<li><p>和信号相关的信息</p>
</li>
<li><p>用户id和组id</p>
</li>
<li><p>会话（Session）和进程组</p>
</li>
<li><p>进程可以使用的资源上限</p>
</li>
</ul>
<h3 id="进程组和会话"><a href="#进程组和会话" class="headerlink" title="进程组和会话"></a>进程组和会话</h3><h4 id="进程组-别名：作业"><a href="#进程组-别名：作业" class="headerlink" title="进程组(别名：作业)"></a>进程组(别名：作业)</h4><ul>
<li>多个进程的集合，每个进程都属于一个进程组，简化对多个进程的管理，<code>waitpid</code>函数和<code>kill</code>函数的参数中用<code>-pid</code>来表示一个进程组。</li>
<li>父进程创建子进程的时候默认父子进程属于同一进程组。进程组的ID==第一个进程ID（组长进程）, 故组长进程标识<code>PGID==PID</code></li>
<li>只要有一个进程存在，进程组就存在，生存期与组长进程是否终止无关</li>
<li>kill -SIGKILL -进程组ID(负数) 杀掉整个进程组</li>
<li>进程组生存期:进程组创建到最后一个进程离开(终止或转移到另一个进程组)</li>
<li>一个进程可以为自己或子进程设置进程组id</li>
</ul>
<h4 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h4><p>多个进程组的集合<br>创建会话的注意事项:</p>
<ol>
<li>调用进程不能是进程组组长,该进程变成新会话首进程(session leader)</li>
<li>该进程成为一个新进程组的组长进程。</li>
<li>新会话丢弃原有的控制终端,该会话没有控制终端</li>
<li>该调用进程是组长进程,则出错返回</li>
<li>建立新会话时,先调用 <code>fork</code>, 父进程终止,子进程调用 <code>setsid()</code></li>
<li>部分linux需要root权限才能创建</li>
</ol>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>Daemon进程，是linux中的后台服务程序，通常独立于控制终端并且周期性地执行某种任务或等待处理<br>某些发生的事件。一般采用以 d 结尾的名字。<br>Linux 后台的一些系统服务进程,没有控制终端,不能直接和用户交互。不受用户登录、注销的影响,一直在<br>运行着,他们都是守护进程。如:预读入缓输出机制的实现;httpd服务器;sshd服务器等。</p>
<h4 id="创建守护进程模型"><a href="#创建守护进程模型" class="headerlink" title="创建守护进程模型"></a>创建守护进程模型</h4><blockquote>
<p>创建守护进程,最关键的一步是调用 <code>setsid</code> 函数创建一个新的 Session,并成为 <code>Session Leader</code>。</p>
</blockquote>
<p>创建步骤：</p>
<ol>
<li>创建子进程,父进程退出<br> 所有工作在子进程中进行形式上脱离了控制终端  </li>
<li>在子进程中创建新会话<br> <code>setsid()</code>函数<br> 使子进程完全独立出来,脱离控制  </li>
<li>改变当前目录位置<br> <code>chdir()</code>函数<br> 防止占用可卸载的文件系统  </li>
<li>重设文件权限掩码<br> <code>umask()</code>函数<br> 防止继承的文件创建屏蔽字拒绝某些权限<br> 增加守护进程灵活性  </li>
<li>关闭文件描述符<br> 继承的打开文件不会用到,浪费系统资源,无法卸载  </li>
<li>开始执行守护进程核心工作守护进程退出处理程序模型    </li>
</ol>
<p>e.g. 简单实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say_error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 父进程任务完成</span></span><br><span class="line"></span><br><span class="line">	pid = setsid();</span><br><span class="line">	<span class="keyword">if</span>(<span class="number">-1</span> == pid) say_error(<span class="string">&quot;setsid error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	chdir(<span class="string">&quot;/var/www/html&quot;</span>); <span class="comment">// 该变工作目录</span></span><br><span class="line">	umask(<span class="number">0022</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 因为新会话没有终端所以不需要 0 1 2</span></span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">if</span>(fd == <span class="number">-1</span>) say_error(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">	dup2(fd, STDOUT_FILENO);  </span><br><span class="line">	dup2(fd, STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>); <span class="comment">// 模拟守护进程业务</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a>fork函数</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值</span><br><span class="line">	成功：父子进程分别返回，在父进程中返回被创建子进程的pid，在子进程中返回0</span><br><span class="line">	失败：-1，设置`errno`，此时没有子进程被创建</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;step 1....\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;step 2....\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;step 3....\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;step 4....\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;fork start....\n&quot;</span>);</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;----child to be created\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t---- current pid = %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t---- my id is %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t---- my parent is %d\n&quot;</span>, getppid());</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;---parent process: my child is %d\n&quot;</span>, pid);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t---- my id is %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\t---- my parent is %d\n&quot;</span>, getppid());</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//sleep(3);</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;============end of file\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<img src="/2022/01/10/process-control/DeepinScreenshot_select-area_20200506231427.png" class="">
<p>循环创建子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (;i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">5</span> == i) &#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		sleep(<span class="number">0.1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth child\n&quot;</span>, i+<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getpid与getppid函数"><a href="#getpid与getppid函数" class="headerlink" title="getpid与getppid函数"></a>getpid与getppid函数</h3><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>返回值： 该函数永远成功返回当前进程的PID或父进程的PID</p>
<h3 id="getuid-与geteuid函数"><a href="#getuid-与geteuid函数" class="headerlink" title="getuid 与geteuid函数"></a>getuid 与geteuid函数</h3><p>获取当前进程实际用户ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取当前进程有效用户ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="getgid-与getegid函数"><a href="#getgid-与getegid函数" class="headerlink" title="getgid 与getegid函数"></a>getgid 与getegid函数</h3><p>获取当前进程使用用户组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取当前进程有效用户组ID</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="getsid函数"><a href="#getsid函数" class="headerlink" title="getsid函数"></a>getsid函数</h3><p>获取进程的会话id</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功返回调用进程会话ID，失败返回-1，设置errno</p>
<h3 id="setsid函数"><a href="#setsid函数" class="headerlink" title="setsid函数"></a>setsid函数</h3><p>创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>成功返回调用进程会话ID，失败返回-1，设置errno</p>
<p>e.g. 简单使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say_error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_session</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current process PID is %d \n&quot;</span>, name, getpid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current process parent PID is %d \n&quot;</span>, name, getppid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current process Group ID is %d \n&quot;</span>, name, getpgid(<span class="number">0</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current process Session ID is %d \n&quot;</span>, name, getsid(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>) say_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pid)&#123; <span class="comment">// 子进程</span></span><br><span class="line">		print_session(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		sleep(<span class="number">3</span>);</span><br><span class="line">		<span class="keyword">if</span>(setsid() == <span class="number">-1</span>) say_error(<span class="string">&quot;setsid error&quot;</span>);  <span class="comment">//设置当前子进程pid为会话id</span></span><br><span class="line">		<span class="comment">// 此后就得到了一个独立且脱离终端控制的新进程, 即无法与用户进行交互</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;chage sid after.....\n&quot;</span>);</span><br><span class="line">		print_session(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//父进程</span></span><br><span class="line">		print_session(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">		wait(<span class="literal">NULL</span>);  <span class="comment">//等待回收子进程</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[parent] current process PID is 7510</span><br><span class="line">[parent] current process parent PID is 7314</span><br><span class="line">[parent] current process Group ID is 7510</span><br><span class="line">[parent] current process Session ID is 5913</span><br><span class="line">[sub] current process PID is 7511</span><br><span class="line">[sub] current process parent PID is 7510</span><br><span class="line">[sub] current process Group ID is 7510</span><br><span class="line">[sub] current process Session ID is 5913</span><br><span class="line">chage sid after.....</span><br><span class="line">[sub] current process PID is 7511</span><br><span class="line">[sub] current process parent PID is 7510</span><br><span class="line">[sub] current process Group ID is 7511</span><br><span class="line">[sub] current process Session ID is 7511</span><br></pre></td></tr></table></figure>



<h3 id="setuid和seteuid函数"><a href="#setuid和seteuid函数" class="headerlink" title="setuid和seteuid函数"></a>setuid和seteuid函数</h3><p><code>setuid（）</code>函数用来设置调用进程的用户ID(real uid和effective uid)<br><code>seteuid</code>函数用来设置调用进程的有效用户ID(effective uid)</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数解释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	uid: 要设置成的用户ID</span><br><span class="line">	euid: 要设置成的有效用户ID</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	successful: 0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<p><strong>注意事项</strong><br><code>setuid()</code>的传入参数<code>uid</code>，根据进程具有的权限情况，可分为以下2种情况：</p>
<ul>
<li>如果进程具有超级用户权限特权，那么就能设置任意的<code>effective uid</code>和<code>real uid</code>, 注意所有与进程有关的用户ID都被设置为<code>uid(非0)</code>,在这种情况发生后，程序就不可能重新获得root权限.  </li>
<li>无特权用户只能用将<code>real uid和effective uid</code>同时设置成<code>real uid或effective uid</code>(e.g. 如果一个用户的<code>real uid</code>为1000，通过设置<code>SGID</code>的方式运行一个root用户的程序，即<code>effective uid</code>为0, 如下图，那么此时<code>setuid()</code>只能传入<code>1000</code>或<code>0</code>)  <img src="/2022/01/10/process-control/setuid_test.png" class="" title="setuid_test">  
因此一个<code>SGID</code>程序希望暂时放弃root权限，以一个无权限用户的身份出现，然后重新获得root权限, 可以使用<code>seteuid()</code>来完成。</li>
</ul>
<hr>
<p>一般来说<code>setuid</code>函数用于降权使用的，一般要和suid（s权限）标志同时使用, 例如apache+php的web服务器 <code>fork</code>一个子进程，然后在用<code>setuid</code>来降低权限，来提高web服务器的安全性。<br>e.g. 简单的使用示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say_error</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>&#123;</span><br><span class="line">	perror(str);</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_uid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current UID is %d \n&quot;</span>, name, getuid());</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[%s] current effective UID is %d \n&quot;</span>, name, geteuid());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span>(pid == <span class="number">-1</span>) say_error(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!pid)&#123; <span class="comment">// 子进程</span></span><br><span class="line">		print_uid(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span>(seteuid(getuid()) == <span class="number">-1</span>) say_error(<span class="string">&quot;setuid error&quot;</span>);  <span class="comment">//降权</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;chage uid after.....\n&quot;</span>);</span><br><span class="line">		print_uid(<span class="string">&quot;sub&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 做一些不需要那么高权限作的事情</span></span><br><span class="line"></span><br><span class="line">	&#125;<span class="keyword">else</span>&#123; <span class="comment">//父进程</span></span><br><span class="line">		print_uid(<span class="string">&quot;parent&quot;</span>);</span><br><span class="line">		wait(<span class="literal">NULL</span>);  <span class="comment">//等待回收子进程</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译并给程序赋予s权限</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; sudo chown 0:0 foo &amp;&amp; sudo chmod u+s foo</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[parent] current UID is 1000</span><br><span class="line">[parent] current effective UID is 0</span><br><span class="line">[sub] current UID is 1000</span><br><span class="line">[sub] current effective UID is 0</span><br><span class="line">chage uid after.....</span><br><span class="line">[sub] current UID is 1000</span><br><span class="line">[sub] current effective UID is 1000</span><br></pre></td></tr></table></figure>


<h3 id="进程共享"><a href="#进程共享" class="headerlink" title="进程共享"></a>进程共享</h3><ul>
<li>父子进程相同之处：<ul>
<li>刚fork后。代码段、data段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式</li>
</ul>
</li>
<li>父子进程不同之处：<ul>
<li>进程id、返回值、各自的父进程、进程创建时间、闹钟、未决信号集</li>
</ul>
</li>
<li>对于全局变量，父子进程间遵循<strong>读时共享写时复制</strong>的原则</li>
<li>父子进程共享：<ol>
<li>文件描述符（打开文件的结构体）</li>
<li>mmap建立的映射区</li>
</ol>
</li>
<li>fork之后，父进程先执行还是子进程先执行不确定。取决于内核所使用的调度算法</li>
</ul>
<h3 id="gdb调试"><a href="#gdb调试" class="headerlink" title="gdb调试"></a>gdb调试</h3><p>使用<code>gdb</code>调试时，<code>gbd</code>只能跟踪一个进程，默认跟踪父进程</p>
<p>可以在调用<code>fork</code>函数之前通过指令来设置<code>gdb</code>跟踪父进程或子进程</p>
<ul>
<li><p><code>set follow-fork-mode child</code>命令设置<code>gdb</code>在<code>fork</code>之后跟踪子进程</p>
</li>
<li><p><code>set follow-fork-mode parent</code>设置跟踪父进程</p>
</li>
</ul>
<p>注意一定要在fork函数<code>调用之前</code>才有效</p>
<h2 id="exec函数族"><a href="#exec函数族" class="headerlink" title="exec函数族"></a>exec函数族</h2><p>当进程调用exec函数时，该进程的用户空间代码段<code>.text</code>与数据段<code>.data</code>完全被新程序替换，然后从新的<code>.text</code>第一条指令开始执行，但进程PID不变，换核不换壳</p>
<p>有六种以exec开头的函数，统称exec函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">           <span class="comment">/*, (char *) NULL, char *const envp[] */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="execlp函数"><a href="#execlp函数" class="headerlink" title="execlp函数"></a>execlp函数</h3><p>加载一个进程，借助PATH环境变量</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...</span></span></span><br><span class="line"><span class="params"><span class="function">		   <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="comment">// NULL 当成传参结束的哨兵</span></span><br><span class="line"><span class="comment">// 比如 execlp(&quot;ls&quot;, &quot;ls&quot;, &quot;-l&quot;, &quot;-h&quot;, (char *)NULL);</span></span><br><span class="line"><span class="comment">// arg 从 argv[0]开始计算，所以要写两个 ls</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数：</p>
<ul>
<li>file：要加载程序的名字，该函数需要配合<code>PATH</code>环境变量来使用，当<code>PATH</code>中所以目录搜索后没有该参数的值则报错</li>
</ul>
</li>
<li><p>返回：</p>
<ul>
<li>成功：无返回</li>
<li>失败：-1</li>
</ul>
</li>
<li><p>该函数通常调用系统程序如<code>cp、ls、date、cat</code></p>
</li>
<li><p>例子：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;  <span class="comment">// 子进程</span></span><br><span class="line">		execlp(<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-lh&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="comment">// 只有exec出错才有机会进入后面代码，否则已经进入别的程序中执行了</span></span><br><span class="line">		perror(<span class="string">&quot;exec error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;  <span class="comment">// 父进程</span></span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent %d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="execl函数"><a href="#execl函数" class="headerlink" title="execl函数"></a>execl函数</h3><ul>
<li><p>指定路径，加载一个进程</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">&quot;./a.out&quot;</span>, <span class="string">&quot;a.out&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">execl(<span class="string">&quot;/usr/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-lah&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="execvp函数"><a href="#execvp函数" class="headerlink" title="execvp函数"></a>execvp函数</h3><ul>
<li><p>函数原型</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br></pre></td></tr></table></figure></li>
<li><p>用法：</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ls_argv[] = &#123;<span class="string">&quot;ls&quot;</span>, <span class="string">&quot;-l&quot;</span>, <span class="string">&quot;-h&quot;</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">execvp(<span class="string">&quot;ls&quot;</span>, ls_argv);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="exec-函数族一般规律"><a href="#exec-函数族一般规律" class="headerlink" title="exec 函数族一般规律"></a>exec 函数族一般规律</h3><ul>
<li>exec函数一旦调用成功即执行新的程序，不返回。只有失败才返回，错误值-1</li>
<li>所以通常直接在exec函数调用后直接调用perror()和exit()，无需if判断</li>
</ul>
<table>
<thead>
<tr>
<th align="center">函数名中的字母</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">l(list)</td>
<td>命令行参数列表</td>
</tr>
<tr>
<td align="center">p(path)</td>
<td>搜索file时使用PATH环境变量</td>
</tr>
<tr>
<td align="center">v(vector)</td>
<td>使用命令行参数数组</td>
</tr>
<tr>
<td align="center">e(environment)</td>
<td>使用环境变量数组，不使用进程原有的环境变量，设置新加载程序运行的环境变量</td>
</tr>
</tbody></table>
<ul>
<li><p>实际上，只有<code>execve</code>是真正的系统调用，其他exec函数最终都调用<code>execve</code>，所以<code>execve</code>在man手册的第二卷，其他函数在man手册的第三卷，这些函数的关系如下图所示：</p>
  <img src="/2022/01/10/process-control/DeepinScreenshot_select-area_20200717183422.png" class=""></li>
</ul>
<h2 id="回收子进程"><a href="#回收子进程" class="headerlink" title="回收子进程"></a>回收子进程</h2><h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><p>孤儿进程：父进程先于子进程结束，则子进程成为孤儿进程，</p>
<p>子进程的父进程成为init进程，称为init进程领养孤儿进程。 </p>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><p>僵尸进程：进程终止，父进程尚未回收，子进程残留资源(PCB) 存在于内核中，变成僵尸进程。</p>
<p>注意：僵尸进程是不能用kill命令清除掉的。因为kill命令只是用来终止进程的，而僵尸进程已经终止了，这种时候只能杀死父进程来终止僵尸进程</p>
<h3 id="wait函数"><a href="#wait函数" class="headerlink" title="wait函数"></a>wait函数</h3><p>父进程调用wait函数可以回收子进程终止信息，该函数有三个功能：</p>
<ol>
<li>阻塞等待子进程退出</li>
<li>回收子进程残留资源</li>
<li>获取子进程结束状态（退出原因）</li>
</ol>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> *wstatus)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">	 wstatus:可以用来传出进程的退出原因</span><br><span class="line">返回值</span><br><span class="line">	成功：清理掉子进程的pid</span><br><span class="line">	失败：返回-1（没有子进程）</span><br></pre></td></tr></table></figure>

<p>当进程终止时，操作系统的隐式回收机制会：</p>
<ol>
<li>关闭所以文件描述符</li>
<li>释放用户空间分配的内存，内核中的PCB仍存在。其中保存该进程的退出状态（正常退出 -&gt; 退出值; 异常退出 -&gt; 终止信号）</li>
</ol>
<p>可使用wait函数传出参数status来保存进程的退出状态，借助宏函数来进一步判断进程终止的具体原因，宏函数可分为三组：</p>
<ol>
<li><p>WIFEXITED(status)：为非0 -&gt; 进程正常结束；</p>
<p> WEXITSTATUS(status) ：如上宏为真，使用此宏获取进程退出状态(exit的参数)</p>
</li>
<li><p>WIFSIGNALED(status) 为非0 -&gt; 进程异常终止</p>
<p> WTERMSIG(status) 如上宏为真，使用此宏取得使进程终止的那个信号的编号。 </p>
</li>
<li><p>WIFSTOPPED(status) 为非0 -&gt; 进程处于暂停状态 </p>
<p> WSTOPSIG(status) 如上宏为真，使用此宏取得使进程暂停的那个信号的编号。<br> WIFCONTINUED(status) 为真 进程暂停后已经继续运行</p>
</li>
</ol>
<h3 id="waitpid-函数"><a href="#waitpid-函数" class="headerlink" title="waitpid 函数"></a>waitpid 函数</h3><p>作用同wait，但可指定pid进程清理，可以不阻塞</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">特殊参数：</span><br><span class="line">	@pid：</span><br><span class="line">		- 大于0： 回收指定pid 的子进程</span><br><span class="line">		- 等于-1：回收任意子进程（相当于wait）</span><br><span class="line">		- 等于 0：回收和当前调用waitpid一个组的所有子进程</span><br><span class="line">		- 小于-1：回收指定进程组内的任意子进程</span><br><span class="line">返回值：</span><br><span class="line">	- 成功：返回清理掉的子进程ID</span><br><span class="line">	- 失败：-1（无子进程）</span><br><span class="line">	- 返回0：函数调用时参数`options`为`WNOHANG`，且子进程正在运行</span><br></pre></td></tr></table></figure>

<p><code>waitpid(-1, &amp;wstatus, 0)</code>等价<code>wait(&amp;wstatus)</code></p>
<p>注意：<strong>一次<code>wait</code>或<code>waitpid</code>调用只能清理一个子进程</strong>，清理多个子进程应使用循环。</p>
<p>e.g.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv, <span class="keyword">char</span>* argc[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(;i &lt; <span class="number">5</span>; ++i)&#123;</span><br><span class="line">		<span class="keyword">if</span> (fork() == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (<span class="number">5</span> == i) &#123; <span class="comment">// parents</span></span><br><span class="line">		<span class="keyword">int</span> wpid = <span class="number">0</span>, wstatus = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((wpid = waitpid(<span class="number">-1</span>, &amp;wstatus, WNOHANG)) != <span class="number">-1</span>) &#123; <span class="comment">//不阻塞回收</span></span><br><span class="line">			<span class="keyword">if</span>(wpid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;catch the child %d \n&quot;</span>, wpid);</span><br><span class="line">				<span class="keyword">if</span>(WIFEXITED(wstatus))</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;reason code: %d\n&quot;</span>, WEXITSTATUS(wstatus));</span><br><span class="line">				<span class="keyword">if</span>(WIFSIGNALED(wstatus))</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;reason code: %d\n&quot;</span>, WTERMSIG(wstatus));</span><br><span class="line">				<span class="keyword">if</span>(WIFSTOPPED(wstatus))</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;reason code: %d\n&quot;</span>, WSTOPSIG(wstatus));</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(wpid == <span class="number">0</span>)&#123;</span><br><span class="line">				sleep(<span class="number">1</span>);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123; <span class="comment">// child</span></span><br><span class="line">		sleep(i);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m %dth child, pid = %d\n&quot;</span>, i+<span class="number">1</span>, getpid());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">233</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">I&#x27;m 1th child, pid = 58902</span><br><span class="line">I&#x27;m 2th child, pid = 58903</span><br><span class="line">I&#x27;m 3th child, pid = 58904</span><br><span class="line">I&#x27;m 4th child, pid = 58905</span><br><span class="line">I&#x27;m 5th child, pid = 58906</span><br><span class="line">catch the child 58902 </span><br><span class="line">reason code: 233</span><br><span class="line">catch the child 58903 </span><br><span class="line">reason code: 233</span><br><span class="line">catch the child 58904 </span><br><span class="line">reason code: 233</span><br><span class="line">catch the child 58905 </span><br><span class="line">reason code: 233</span><br><span class="line">catch the child 58906 </span><br><span class="line">reason code: 233</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wakaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wakaka6.github.io/2022/01/10/process-control/">https://wakaka6.github.io/2022/01/10/process-control/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wakaka6.github.io" target="_blank">wakaka</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux-program/">linux_program</a></div><div class="post_share"><div class="social-share" data-image="/img/page/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/13/interProcessCommunication/"><img class="prev-cover" src="/img/page/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">进程间通信相关系统调用</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/10/file-io/"><img class="next-cover" src="/img/page/2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">文件相关系统调用-file_io</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用"><img class="cover" src="/img/page/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">进程间通信相关系统调用</div></div></a></div><div><a href="/2022/01/10/file-io/" title="文件相关系统调用-file_io"><img class="cover" src="/img/page/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">文件相关系统调用-file_io</div></div></a></div><div><a href="/2022/01/15/signal/" title="linux信号总结"><img class="cover" src="/img/page/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-15</div><div class="title">linux信号总结</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wakaka</div><div class="author-info__description">一个linux爱好者</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wakaka6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wakaka6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wakaka6@github.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Hello World.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E8%A7%A3%E9%87%8A"><span class="toc-number">1.1.</span> <span class="toc-text">进程相关概念解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">程序与进程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E4%B8%8E%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟内存与物理内存的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">1.1.3.</span> <span class="toc-text">PCB 进程控制块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84%E5%92%8C%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.1.4.</span> <span class="toc-text">进程组和会话</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%BB%84-%E5%88%AB%E5%90%8D%EF%BC%9A%E4%BD%9C%E4%B8%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">进程组(别名：作业)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">会话</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">守护进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">创建守护进程模型</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.2.</span> <span class="toc-text">进程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">fork函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getpid%E4%B8%8Egetppid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">getpid与getppid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getuid-%E4%B8%8Egeteuid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.3.</span> <span class="toc-text">getuid 与geteuid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getgid-%E4%B8%8Egetegid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.4.</span> <span class="toc-text">getgid 与getegid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getsid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.5.</span> <span class="toc-text">getsid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setsid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.6.</span> <span class="toc-text">setsid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setuid%E5%92%8Cseteuid%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.7.</span> <span class="toc-text">setuid和seteuid函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%85%B1%E4%BA%AB"><span class="toc-number">1.2.8.</span> <span class="toc-text">进程共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gdb%E8%B0%83%E8%AF%95"><span class="toc-number">1.2.9.</span> <span class="toc-text">gdb调试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exec%E5%87%BD%E6%95%B0%E6%97%8F"><span class="toc-number">1.3.</span> <span class="toc-text">exec函数族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execlp%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.</span> <span class="toc-text">execlp函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execl%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.2.</span> <span class="toc-text">execl函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#execvp%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">execvp函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E5%87%BD%E6%95%B0%E6%97%8F%E4%B8%80%E8%88%AC%E8%A7%84%E5%BE%8B"><span class="toc-number">1.3.4.</span> <span class="toc-text">exec 函数族一般规律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">回收子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.1.</span> <span class="toc-text">孤儿进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.4.2.</span> <span class="toc-text">僵尸进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">wait函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waitpid-%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">waitpid 函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go编译相关环境变量"/></a><div class="content"><a class="title" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量">go编译相关环境变量</a><time datetime="2022-04-14T10:04:18.000Z" title="发表于 2022-04-14 18:04:18">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/nmap/" title="nmap"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nmap"/></a><div class="content"><a class="title" href="/2022/04/02/nmap/" title="nmap">nmap</a><time datetime="2022-04-02T14:06:43.000Z" title="发表于 2022-04-02 22:06:43">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/py-decorator/" title="python装饰器详解"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python装饰器详解"/></a><div class="content"><a class="title" href="/2022/01/17/py-decorator/" title="python装饰器详解">python装饰器详解</a><time datetime="2022-01-17T12:49:06.000Z" title="发表于 2022-01-17 20:49:06">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/signal/" title="linux信号总结"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux信号总结"/></a><div class="content"><a class="title" href="/2022/01/15/signal/" title="linux信号总结">linux信号总结</a><time datetime="2022-01-14T18:52:59.000Z" title="发表于 2022-01-15 02:52:59">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程间通信相关系统调用"/></a><div class="content"><a class="title" href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用">进程间通信相关系统调用</a><time datetime="2022-01-12T17:55:04.000Z" title="发表于 2022-01-13 01:55:04">2022-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wakaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>