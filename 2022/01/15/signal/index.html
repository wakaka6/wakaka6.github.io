<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>linux信号总结 | wakaka</title><meta name="keywords" content="linux_program,c"><meta name="author" content="wakaka"><meta name="copyright" content="wakaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="信号A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停执行，去处理信号，处理完毕后在继续执行。与硬件中断类似（异步模式）。但信号是软件层面上实现的中断，早期被称为软中断.   信号的共性：简单、不能携带大量信息、满足条件才能发送。 信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对用户来说，这个延迟时间非常短，不易察觉。 每个进">
<meta property="og:type" content="article">
<meta property="og:title" content="linux信号总结">
<meta property="og:url" content="https://wakaka6.github.io/2022/01/15/signal/index.html">
<meta property="og:site_name" content="wakaka">
<meta property="og:description" content="信号A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停执行，去处理信号，处理完毕后在继续执行。与硬件中断类似（异步模式）。但信号是软件层面上实现的中断，早期被称为软中断.   信号的共性：简单、不能携带大量信息、满足条件才能发送。 信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对用户来说，这个延迟时间非常短，不易察觉。 每个进">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wakaka6.github.io/img/page/3.jpg">
<meta property="article:published_time" content="2022-01-14T18:52:59.000Z">
<meta property="article:modified_time" content="2022-04-14T10:05:30.042Z">
<meta property="article:author" content="wakaka">
<meta property="article:tag" content="linux_program">
<meta property="article:tag" content="c">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wakaka6.github.io/img/page/3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wakaka6.github.io/2022/01/15/signal/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'linux信号总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-14 18:05:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/page/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wakaka</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">linux信号总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-14T18:52:59.000Z" title="发表于 2022-01-15 02:52:59">2022-01-15</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-14T10:05:30.042Z" title="更新于 2022-04-14 18:05:30">2022-04-14</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="linux信号总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h1><p>A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停执行，去处理信号，处理完毕后在继续执行。<br>与硬件中断类似（异步模式）。但信号是软件层面上实现的中断，早期被称为<em>软中断</em>.  </p>
<p>信号的共性：简单、不能携带大量信息、满足条件才能发送。</p>
<p>信号的特质：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对用户来说，这个延迟时间非常短，不易察觉。</p>
<p><strong>每个进程收到的所有信号，都是由内核负责发送以及处理的</strong> </p>
<h3 id="与信号相关的事件和状态"><a href="#与信号相关的事件和状态" class="headerlink" title="与信号相关的事件和状态"></a>与信号相关的事件和状态</h3><p>产生信号的方式如下表：</p>
<table>
<thead>
<tr>
<th>事件</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>按键产生</td>
<td><code>Ctrl+c</code>、<code>Ctrl+z</code>、<code>Ctrl+\</code></td>
</tr>
<tr>
<td>系统调用产生</td>
<td><code>kill</code>、<code>raise</code>、 <code>abort</code></td>
</tr>
<tr>
<td>软件条件产生</td>
<td>定时器alarm</td>
</tr>
<tr>
<td>硬件异常产生</td>
<td>非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)</td>
</tr>
<tr>
<td>命令产生</td>
<td><code>kill</code></td>
</tr>
</tbody></table>
<p>递达：递送并且到达进程。<br>未决：产生和递达之间的状态。主要由于阻塞（屏蔽）导致该状态</p>
<p>信号处理的方式：</p>
<ol>
<li>执行默认动作(即进程不去处理)</li>
<li>忽略（丢弃）</li>
<li>捕捉（调用用户处理函数）</li>
</ol>
<p>在linux的实现PCB的结构体<code>task_struct</code>中包含了信号相关的信息，主要是指阻塞信号集和未决信号集。</p>
<img src="/2022/01/15/signal/sigmask.png" class="" title="sigmask">
<ul>
<li>阻塞信号集（信号屏蔽字）：将某些信号加入集合，对他们设置屏蔽(对应位 置1)，当屏蔽某信号后，在收到该信号，该信号的处理将延后（解除屏蔽后）</li>
<li>未决信号集：<ol>
<li>信号产生，未决信号集中描述该信号的位立即翻转为1, 表示信号处于为未决状态。当信号被处理对应位翻转回0。这一时刻往往非常短暂。</li>
<li>信号产生后由于某些原因（主要是阻塞）不能抵达。这类信号的集合称为未决信号集。在屏蔽解除前，信号一直处于未决状态。</li>
</ol>
</li>
</ul>
<p>不存在编号为0的信号。其中1-31号信号称之为常规信号（也叫普通信号或标准信号），34-64称为实时信号，驱动编程与硬件相关。名字上区别不大。而前32个名字各不相同。<br>信号值被定义在文件 <code>/usr/include/bits/signum.h</code> 中，其源文件是 <code>/usr/src/linux/kernel/signal.c</code>。<br>在 Linux 下，可以查看 signal(7) 手册页来查阅信号名列表、信号值、默认的行为和它们是否可以被捕获。其命令如下所示：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 7 signal</span><br></pre></td></tr></table></figure>

<p>下表列出Linux中常见的进程信号：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>名称</th>
<th>事件</th>
<th>默认操作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>SIGHUP</td>
<td>（Hangup）当你不在控制终端时，或者当你关闭gnome-termnal或断开modem内核会产生该信号。由于后台进程没有控制的终端，因而它们常用<code>SIGUP</code>来发出需要重新读取其配置文件的信号。</td>
<td>(Abort)挂断控制终端信号或进程。</td>
</tr>
<tr>
<td>2</td>
<td>SIGINT</td>
<td>(Interrupt)来自键盘的中断。通常终端驱动程序会将其与<code>Ctrl+c</code>绑定</td>
<td>(Abort)终止程序</td>
</tr>
<tr>
<td>3</td>
<td>SIGQUIT</td>
<td>(Interrupt)来自键盘的中断。通常终端驱动程序会将其与<code>Ctrl+\</code>绑定</td>
<td>(Dump)程序被终止并产生dump core文件。</td>
</tr>
<tr>
<td>4</td>
<td>SIGILL</td>
<td>（Illegal Instruction）程序出错或执行了一个非法的操作命令</td>
<td>(Dump)程序被终止并产生dump core文件。</td>
</tr>
<tr>
<td>5</td>
<td>SIGTRAP</td>
<td>（Breakpoint/Trace Trap）调试用，跟踪断点</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>SIGABRT</td>
<td>（Abort）放弃执行，异常结束。</td>
<td>(Dump)程序被终止并产生dump core文件。</td>
</tr>
<tr>
<td>7</td>
<td>SIGBUS</td>
<td>（Bus）当进程引起一个总线错误时，BUS 信号将被发送到进程。例如，访问了一部分未定义的内存对象</td>
<td>(Dump)程序被终止并产生dump core文件。</td>
</tr>
<tr>
<td>8</td>
<td>SIGFPE</td>
<td>（Floating Point Exeception）浮点异常</td>
<td>(Dump)程序被终止并产生dump core文件。</td>
</tr>
<tr>
<td>9</td>
<td>SIGKILL</td>
<td>（Kill）程序被终止。该信号不能被捕获或被忽略。想立即终止一个进程就发送信号9.注意程序将没有任何机会做清理工作。</td>
<td>(Abort) 程序被终止。</td>
</tr>
<tr>
<td>10</td>
<td>SIGUSR1</td>
<td>(User defined Signal 1) 用户定义的信号。</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>11</td>
<td>SIGSEGV</td>
<td>(Segmentation Violation) 当程序引用无效的内存时会产生此信号。比如：寻址没有映射的内存；寻址未许可的内存。</td>
<td>(Dump) 程序被终止并产生 dump core 文件。</td>
</tr>
<tr>
<td>12</td>
<td>SIGUSR2</td>
<td>(User defined Signal 2) 保留给用户程序用于 IPC 或其他目的。</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>13</td>
<td>SIGPIPE</td>
<td>(Pipe) 当程序向一个套接字或管道写时由于没有读者而产生该信号</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>14</td>
<td>SIGALRM</td>
<td>(Alarm) 该信号会在用户调用 alarm系统调用所设置的延迟秒数到后产生。该信号常用判别于系统调用超时。</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>15</td>
<td>SIGTERM</td>
<td>(Terminate) 用于和善地要求一个程序终止。它是 kill的默认信号。与 SIGKILL 不同，该信号能被捕获，这样就能在退出运行前做清理工作。</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>16</td>
<td>SIGSTKFLT</td>
<td>(Stack fault on coprocessor) 协处理器堆栈错误。</td>
<td>(Abort) 进程被终止。</td>
</tr>
<tr>
<td>17</td>
<td>SIGCHLD</td>
<td>(Child) 停止或终止子进程。可改变其含义挪作它用。</td>
<td>(Ignore) 子进程停止或结束。</td>
</tr>
<tr>
<td>18</td>
<td>SIGCONT</td>
<td>(Continue) 该信号致使被 SIGSTOP 停止的进程恢复运行。可以被捕获。</td>
<td>(Continue)  恢复进程 的执行。</td>
</tr>
<tr>
<td>19</td>
<td>SIGSTOP</td>
<td>(Stop) 停止进程的运行。该信号不可被捕获或忽略</td>
<td>(Stop) 停止进程运行。</td>
</tr>
<tr>
<td>20</td>
<td>SIGTSTP</td>
<td>(Terminal Stop) 向终端发送停止键序列。该信号可以被捕获或忽略。</td>
<td>(Stop) 停止进程运行。</td>
</tr>
<tr>
<td>21</td>
<td>SIGTTIN</td>
<td>(Terminal Input on Background) 后台进程试图从一个不再被控制的终端上读取数据，此时该进程将被停止，直到收到 SIGCONT 信号。该信号可以被捕获或忽略。</td>
<td>(Stop) 停止进程运行。</td>
</tr>
<tr>
<td>22</td>
<td>SIGTTOU</td>
<td>(TTY Output on Background) 后台进程试图向一个不再被控制的终端上输出数据，此时该进程将被停止，直到收到 SIGCONT 信号。该信号可被捕获或忽略。</td>
<td>(Stop) 停止进程运行。</td>
</tr>
</tbody></table>
<blockquote>
<p>tips: 只有每个信号所对应的事件发生了，该信号才会被递送（但不一定递达），不应乱发信号！</p>
</blockquote>
<hr>
<p>当程序运行的过程中出现异常终止或崩溃，系统就会将程序崩溃时的内存、寄存器状态、堆栈指针、内存管理信息记录下来，保存在一个文件中，叫作<strong>核心转储(Core Dump)</strong><br>可以通过以下操作开启核心转储并修改核心转储文件的保存路径  </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c    <span class="comment"># 默认关闭 0 </span></span><br><span class="line"><span class="built_in">ulimit</span> -c unlimited  <span class="comment"># 临时开启</span></span><br><span class="line">sudoedit /etc/security/limits.conf       <span class="comment"># 将core的value 0修改成unlimited，永久开启</span></span><br><span class="line"><span class="comment">#&lt;domain&gt;      &lt;type&gt;  &lt;item&gt;         &lt;value&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#*               soft    core            0</span></span><br><span class="line">*               soft    core            unlimited</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 core_users_pid, 使核心转储文件名变为core.[pid]</span></span><br><span class="line"><span class="built_in">echo</span> 1 &gt; /proc/sys/kernel/core_uses_pid</span><br><span class="line"><span class="comment"># 还可以修改 core_pattern, 保存到/tmp目录，文件名为 core-[filename]-[pid]-[time]</span></span><br><span class="line"><span class="built_in">echo</span> /tmp/core-%e-%p-%t &gt; /proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>

<p>若有一个核心转储文件，可以使用gdb进行调试</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb [filename] [core file]</span><br><span class="line"><span class="comment"># gdb a.out /tmp/core-a.out-12345-123123123</span></span><br></pre></td></tr></table></figure>

<h3 id="系统调用产生信号"><a href="#系统调用产生信号" class="headerlink" title="系统调用产生信号"></a>系统调用产生信号</h3><h4 id="kill函数"><a href="#kill函数" class="headerlink" title="kill函数"></a>kill函数</h4><blockquote>
<p>该函数用来发生一个信号给一个进程</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>
<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	pid:</span><br><span class="line">		&gt;0: 发送信号给指定的进程</span><br><span class="line">		=0: 发送信号给 与调用kill函数进程属于同一进程组的所有进程</span><br><span class="line">		=-1: 发送给进程有权限发送的系统中所有进程</span><br><span class="line">		&lt;-1: 取|pid|发给对应进程组</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	sucessful: 至少有一个信号被发生，返回0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<p>进程组：每个进程都属于一个进程组，进程组是一个或多个进程集合，他们互相关联，共同完成一个实体任务，每个进程组都有一个进程组长，默认进程组ID与进程组长ID相同.</p>
<p>权限保护：</p>
<ul>
<li>超级用户可以发送信号给任意用户  </li>
<li>普通用户没有权限向系统用户以及其他普通用户发送信号  </li>
<li>普通用户的基本规则是：<strong>发送者实际或有效UID==接受者实际或有效UID</strong>  </li>
</ul>
<h4 id="封装了kill函数的几个发出信号的函数"><a href="#封装了kill函数的几个发出信号的函数" class="headerlink" title="封装了kill函数的几个发出信号的函数"></a>封装了<code>kill函数</code>的几个发出信号的函数</h4><p>raise函数</p>
<blockquote>
<p>当进程中只有一个线程的适合它等价于<code>kill(getuid(), sig)</code><br>当进程中只有多个线程的适合它等价于<code>pthread_kill(pthread_self(), sig)</code>  </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @return: </span></span><br><span class="line"><span class="comment">	- sucessful: 0</span></span><br><span class="line"><span class="comment">	- failure: 非0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>abort函数</p>
<blockquote>
<p>该函数永远没有返回值，其等价于<code>raise(SIGABRT)</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function">noreturn <span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>


<h3 id="软件条件产生信号"><a href="#软件条件产生信号" class="headerlink" title="软件条件产生信号"></a>软件条件产生信号</h3><h4 id="alarm函数"><a href="#alarm函数" class="headerlink" title="alarm函数"></a>alarm函数</h4><p>每个进程都有且只有唯一一个定时器, 本质就是PCB中的<code>alarm</code>变量。<br>在指定seconds后(设置<code>current-&gt;alarm</code>)，在CPU数了seconds包含的总系统滴答后，即当前<u>进程<code>task_struct</code>的成员变量<code>alarm</code></u> 小于 <u>系统从开机算起的滴答数<code>jiffies</code></u> (<code>current-&gt;alarm &amp;&amp; current-&gt;alarm &lt; jiffies</code>)时，内核会给当前进程发送<code>SIGALRM信号</code>。系统收到该信号，默认动作终止。</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">alarm</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span></span>&#123; </span><br><span class="line">	<span class="keyword">int</span> old = current-&gt;alarm;</span><br><span class="line">	<span class="keyword">if</span>(old) old = (old - jiffies) / HZ;</span><br><span class="line"></span><br><span class="line">	current-&gt;alarm = (seconds &gt; <span class="number">0</span>)? (jiffies + HZ * seconds): <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	seconds: 要设置定时的秒数</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	1. 在程序中第一次设置报警定时间值，返回0</span><br><span class="line">	2. 其他情况返回继上次设置后的剩余秒数</span><br><span class="line">	没有出错的情况</span><br></pre></td></tr></table></figure>

<p>用法示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alarm(<span class="number">5</span>); <span class="comment">// 设置定时时间为5</span></span><br><span class="line">alarm(<span class="number">0</span>); <span class="comment">// 取消定时器，返回闹钟剩余秒数</span></span><br></pre></td></tr></table></figure>

<h3 id="setitimer函数"><a href="#setitimer函数" class="headerlink" title="setitimer函数"></a>setitimer函数</h3><p>设置定时器。可代替alarm函数。精度微秒us，可实现周期定时</p>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_interval</span>;</span> <span class="comment">/* Interval for periodic timer */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">it_value</span>;</span>    <span class="comment">/* Time until next expiration */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">	<span class="keyword">time_t</span>      tv_sec;         <span class="comment">/* seconds */</span></span><br><span class="line">	<span class="keyword">suseconds_t</span> tv_usec;        <span class="comment">/* microseconds */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getitimer</span><span class="params">(<span class="keyword">int</span> which, struct itimerval *curr_value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setitimer</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">const</span> struct itimerval *<span class="keyword">restrict</span> new_value,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct itimerval *<span class="keyword">restrict</span> old_value)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	which: 指定定时方式</span><br><span class="line">		- 自然定时：ITIMER_REAL -&gt; SIGLARM</span><br><span class="line">		- 只计算进程占用CPU的时间（用户空间）：ITIMER_VIRTUAL -&gt; SIGVTALRM </span><br><span class="line">		- 计算占用CPU及执行系统调用的时间（用户+内核）：ITIMER_PROF -&gt; SIGPROF</span><br><span class="line">	new_value: 定时秒数</span><br><span class="line">	old_value: 传出参数，上次定时剩余时间。</span><br><span class="line">	curr_value: 传出参数，上次定时剩余时间。</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	sucessful: 0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<p>e.g.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">it</span>, <span class="title">oldit</span>;</span></span><br><span class="line">	<span class="comment">// 初次设置定时时间, 若为0,则关闭计时器</span></span><br><span class="line">	it.it_value.tv_sec = <span class="number">1</span>;</span><br><span class="line">	it.it_value.tv_usec = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 设置周期定时时间，时间到了会自动重载current-&gt;alarm</span></span><br><span class="line">	it.it_interval.tv_sec = <span class="number">1</span>;</span><br><span class="line">	it.it_interval.tv_usec = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	signal(SIGALRM, foo);  <span class="comment">// 注册foo函数捕捉信号SIGALRM</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(setitimer(ITIMER_REAL, &amp;it, &amp;oldit) == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;setitimer error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="信号集操作函数"><a href="#信号集操作函数" class="headerlink" title="信号集操作函数"></a>信号集操作函数</h3><h4 id="自定义信号集"><a href="#自定义信号集" class="headerlink" title="自定义信号集"></a>自定义信号集</h4><blockquote>
<p><code>sigset_t</code>类型本质是位图，但不应该直接使用位操作，而应该使用下面的函数来保证程序的可移植性。</p>
</blockquote>
<p>设定自定义信号集函数如下表，它们的头文件都是<code>signal.h</code></p>
<table>
<thead>
<tr>
<th>函数原型</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td><code>int sigemptyset(sigset_t *set);</code></td>
<td>将信号集<code>set</code>全清0</td>
<td>return 0 on sucess and -1 on error</td>
</tr>
<tr>
<td><code>int sigfillset(sigset_t *set);</code></td>
<td>将信号集<code>set</code>全置1</td>
<td>return 0 on sucess and -1 on error</td>
</tr>
<tr>
<td><code>int sigaddset(sigset_t *set, int signum);</code></td>
<td>将信号<code>signum</code>加入集合<code>set</code>中</td>
<td>return 0 on sucess and -1 on error</td>
</tr>
<tr>
<td><code>int sigdelset(sigset_t *set, int signum);</code></td>
<td>将集合<code>set</code>中删除信号<code>signum</code></td>
<td>return 0 on sucess and -1 on error</td>
</tr>
<tr>
<td><code>int sigismember(const sigset_t *set, int signum);</code></td>
<td>查找信号<code>signum</code>是否在集合<code>set</code>中</td>
<td><code>signum</code>在集合<code>set</code>中：1,不在：0,出错：-1</td>
</tr>
</tbody></table>
<h4 id="操作信号屏蔽字"><a href="#操作信号屏蔽字" class="headerlink" title="操作信号屏蔽字"></a>操作信号屏蔽字</h4><blockquote>
<p>可以用sigprocmask函数来操作PCB中的信号屏蔽字来达到屏蔽信号、解除屏蔽信号的效果。</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span> *<span class="built_in">set</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="keyword">sigset_t</span> *oldset)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	how: 做什么操作</span><br><span class="line">		- SIG_BLOCK: 将自定义set中的信号添加到mask</span><br><span class="line">		- SIG_UNBLOCK: 将自set中的信号从mask中删除</span><br><span class="line">		- SIG_SETMASK: 用自定义set替换mask</span><br><span class="line">	set: 用户定义的信号集。</span><br><span class="line">	oldset: 传出参数，在被设置前的信号屏蔽字</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	sucessful: 0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<h4 id="查看未决信号集"><a href="#查看未决信号集" class="headerlink" title="查看未决信号集"></a>查看未决信号集</h4><blockquote>
<p>可以用<code>sigpending</code> 函数查看PCB中未决信号的状态</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	set: 传出参数，将未决信号集传出到set中</span><br><span class="line"></span><br><span class="line">@return：</span><br><span class="line">	sucessful: 0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 打印未决信号集 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_set</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGINT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = sigprocmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;sigprocmask error&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		ret = sigpending(&amp;<span class="built_in">set</span>);</span><br><span class="line">		<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">			perror(<span class="string">&quot;sigpending error&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		print_set(&amp;<span class="built_in">set</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_set</span><span class="params">(<span class="keyword">sigset_t</span> *<span class="built_in">set</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">32</span>; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(sigismember(<span class="built_in">set</span>, i))</span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="信号捕捉"><a href="#信号捕捉" class="headerlink" title="信号捕捉"></a>信号捕捉</h3><p>信号处理程序的调用方式如下图</p>
<img src="/2022/01/15/signal/signal_procedure.png" class="" title="signal_procedure">

<h4 id="signal函数"><a href="#signal函数" class="headerlink" title="signal函数"></a>signal函数</h4><blockquote>
<p><code>signal</code>函数用于注册一个信号的捕捉函数,它由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用<code>sigaction</code>函数。</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="comment">// 当signum信号递达时，由handler函数处理</span></span><br><span class="line"><span class="function"><span class="keyword">sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="sigaction函数"><a href="#sigaction函数" class="headerlink" title="sigaction函数"></a>sigaction函数</h4><blockquote>
<p>修改信号处理动作，用来注册一个信号的捕捉函数</p>
</blockquote>
<p>函数原型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_handler)(<span class="keyword">int</span>);  <span class="comment">// 默认使用的回调函数</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);  <span class="comment">// 当sa_flag被设置成SA_INFO时使用这个类型的回调函数</span></span><br><span class="line">	<span class="keyword">sigset_t</span>   sa_mask;  <span class="comment">// 在这个集合的信号会在执行回调函数期间被屏蔽, 防止多级中断，传空集会自动屏蔽signum信号</span></span><br><span class="line">	<span class="keyword">int</span>        sa_flags; <span class="comment">// 用来决定sigaction函数的行为，一般传0, 设置了SA_NODEFER就不会自动屏蔽signum信号</span></span><br><span class="line">	<span class="keyword">void</span>     (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> signum, <span class="keyword">const</span> struct sigaction *<span class="keyword">restrict</span> act,</span></span></span><br><span class="line"><span class="params"><span class="function">		struct sigaction *<span class="keyword">restrict</span> oldact)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@param:</span><br><span class="line">	signum: 信号编号</span><br><span class="line">	act： 不为NULL时signum信号的处理动作被设置成act</span><br><span class="line">	oldact：不为NULL时signum信号的上一个处理动作被传出到oldact中</span><br><span class="line"></span><br><span class="line">@return:</span><br><span class="line">	sucessful: 0</span><br><span class="line">	failure: -1, set errno</span><br></pre></td></tr></table></figure>

<p>e.g. 简单的使用测试</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_foo</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;  <span class="comment">//运行期间屏蔽signo|SIGQUIT</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;catch you!! %d\n&quot;</span>, signo);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">	sigprocmask(SIG_SETMASK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>); <span class="comment">// 屏蔽Ctrl+&quot;\&quot;  </span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>, <span class="title">oldact</span>;</span></span><br><span class="line">	act.sa_handler = sig_foo;  <span class="comment">// 设置信号递达后的回调函数</span></span><br><span class="line">	sigemptyset(&amp;act.sa_mask); <span class="comment">// 使sig_foo被调用时要屏蔽的信号为空集，但此时也会屏蔽被捕捉的信号</span></span><br><span class="line">	act.sa_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> ret = sigaction(SIGINT, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	ret = sigaction(SIGBUS, &amp;act, &amp;oldact);</span><br><span class="line">	<span class="keyword">if</span>(ret == <span class="number">-1</span>)&#123;</span><br><span class="line">		perror(<span class="string">&quot;sigaction error&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="信号捕捉特性"><a href="#信号捕捉特性" class="headerlink" title="信号捕捉特性"></a>信号捕捉特性</h4><ol>
<li>程序正常运行时，PCB中有一个信号屏蔽集，当注册了某个捕捉函数，且捕捉到了该信号后，此时会有一个临时的屏蔽集<code>sa_mask</code>，在函数回调过程中，信号的屏蔽集为临时的屏蔽集和原来的屏蔽集的并集，函数调用结束后，再恢复到原来的屏蔽集。</li>
<li>xxx信号捕捉函数执行期间，xxx信号被自动屏蔽.</li>
<li>阻塞的常规信号不支持排队，产生多次只记录一次.<del>后32个实时信号支持排队</del></li>
</ol>
<h4 id="使用信号回收子进程"><a href="#使用信号回收子进程" class="headerlink" title="使用信号回收子进程"></a>使用信号回收子进程</h4><p><code>SIGCHLD</code>信号的产生条件：</p>
<ul>
<li>子进程终止时</li>
<li>子进程接受到<code>SIGSTOP</code>信号停止时</li>
<li>子进程处于停止态，接受到<code>SIGCONT</code>后唤醒时</li>
</ul>
<p>e.g. 借助<code>SIGCHLD</code>信号回收子进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRO_POOL 5 <span class="comment">//进程池的数量</span></span></span><br><span class="line"><span class="keyword">int</span> child_end = <span class="number">0</span>; <span class="comment">// 子进程死亡的数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signum)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> wpid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(( wpid = wait(<span class="literal">NULL</span>) ) != <span class="number">-1</span>)  <span class="comment">//循环回收，防止多个子进程同时白给,只能回收一个的情况</span></span><br><span class="line">	&#123;</span><br><span class="line">		++child_end;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[%d] catch the %d child\n&quot;</span>, signum, wpid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD);</span><br><span class="line">	sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>); <span class="comment">// 提前阻塞SIGCHILD信号，防止子进程在父进程注册回调函数之前死亡</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(;i &lt; PRO_POOL; ++i)</span><br><span class="line">		<span class="keyword">if</span>(!(pid = fork())) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(PRO_POOL == i)&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">		act.sa_handler = catch_child;</span><br><span class="line">		sigemptyset(&amp;act.sa_mask);</span><br><span class="line">		sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">		sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>); <span class="comment">// 开始捕获SIGCHLD信号</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent %d\n&quot;</span>, getpid());</span><br><span class="line">		<span class="keyword">while</span>(child_end != PRO_POOL); <span class="comment">//回收完所有子进程，父进程结束</span></span><br><span class="line">		child_end ^= child_end;</span><br><span class="line">		</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\tI&#x27;m child %d\n&quot;</span>, getpid());</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\tover ....\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wakaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wakaka6.github.io/2022/01/15/signal/">https://wakaka6.github.io/2022/01/15/signal/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wakaka6.github.io" target="_blank">wakaka</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/linux-program/">linux_program</a><a class="post-meta__tags" href="/tags/c/">c</a></div><div class="post_share"><div class="social-share" data-image="/img/page/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/17/py-decorator/"><img class="prev-cover" src="/img/page/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">python装饰器详解</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/13/interProcessCommunication/"><img class="next-cover" src="/img/page/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">进程间通信相关系统调用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用"><img class="cover" src="/img/page/1.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">进程间通信相关系统调用</div></div></a></div><div><a href="/2022/01/10/file-io/" title="文件相关系统调用-file_io"><img class="cover" src="/img/page/2.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">文件相关系统调用-file_io</div></div></a></div><div><a href="/2022/01/10/process-control/" title="进程控制相关函数"><img class="cover" src="/img/page/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-10</div><div class="title">进程控制相关函数</div></div></a></div><div><a href="/2022/01/07/simple-webserver/" title="simple-webserver"><img class="cover" src="/img/page/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">simple-webserver</div></div></a></div><div><a href="/2021/12/27/socket-study/" title="socket_study"><img class="cover" src="/img/page/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-27</div><div class="title">socket_study</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wakaka</div><div class="author-info__description">一个linux爱好者</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">10</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wakaka6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wakaka6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wakaka6@github.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Hello World.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.</span> <span class="toc-text">信号</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BF%A1%E5%8F%B7%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%92%8C%E7%8A%B6%E6%80%81"><span class="toc-number">1.0.1.</span> <span class="toc-text">与信号相关的事件和状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.2.</span> <span class="toc-text">系统调用产生信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kill%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">kill函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%81%E8%A3%85%E4%BA%86kill%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E5%8F%91%E5%87%BA%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">封装了kill函数的几个发出信号的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%9D%A1%E4%BB%B6%E4%BA%A7%E7%94%9F%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.0.3.</span> <span class="toc-text">软件条件产生信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#alarm%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.3.1.</span> <span class="toc-text">alarm函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setitimer%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.4.</span> <span class="toc-text">setitimer函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%9B%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.5.</span> <span class="toc-text">信号集操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.0.5.1.</span> <span class="toc-text">自定义信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E4%BF%A1%E5%8F%B7%E5%B1%8F%E8%94%BD%E5%AD%97"><span class="toc-number">1.0.5.2.</span> <span class="toc-text">操作信号屏蔽字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%9C%AA%E5%86%B3%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-number">1.0.5.3.</span> <span class="toc-text">查看未决信号集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.5.4.</span> <span class="toc-text">使用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89"><span class="toc-number">1.0.6.</span> <span class="toc-text">信号捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#signal%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.1.</span> <span class="toc-text">signal函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.6.2.</span> <span class="toc-text">sigaction函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%8D%95%E6%8D%89%E7%89%B9%E6%80%A7"><span class="toc-number">1.0.6.3.</span> <span class="toc-text">信号捕捉特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.0.6.4.</span> <span class="toc-text">使用信号回收子进程</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go编译相关环境变量"/></a><div class="content"><a class="title" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量">go编译相关环境变量</a><time datetime="2022-04-14T10:04:18.000Z" title="发表于 2022-04-14 18:04:18">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/nmap/" title="nmap"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nmap"/></a><div class="content"><a class="title" href="/2022/04/02/nmap/" title="nmap">nmap</a><time datetime="2022-04-02T14:06:43.000Z" title="发表于 2022-04-02 22:06:43">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/py-decorator/" title="python装饰器详解"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python装饰器详解"/></a><div class="content"><a class="title" href="/2022/01/17/py-decorator/" title="python装饰器详解">python装饰器详解</a><time datetime="2022-01-17T12:49:06.000Z" title="发表于 2022-01-17 20:49:06">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/signal/" title="linux信号总结"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux信号总结"/></a><div class="content"><a class="title" href="/2022/01/15/signal/" title="linux信号总结">linux信号总结</a><time datetime="2022-01-14T18:52:59.000Z" title="发表于 2022-01-15 02:52:59">2022-01-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程间通信相关系统调用"/></a><div class="content"><a class="title" href="/2022/01/13/interProcessCommunication/" title="进程间通信相关系统调用">进程间通信相关系统调用</a><time datetime="2022-01-12T17:55:04.000Z" title="发表于 2022-01-13 01:55:04">2022-01-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wakaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>