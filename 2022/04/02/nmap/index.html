<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>nmap | wakaka</title><meta name="keywords" content="nmap,pentest,information security"><meta name="author" content="wakaka"><meta name="copyright" content="wakaka"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="nmap0x01 活跃主机发现技术注意：使用任何扫描工具得到的扫描结果仅供参考  nmap主机发现技术分析  nmap中提供了--packet-trace选项来观察nmap发出了哪些数据包，收到了哪些数据包，由此可知nmap在进行主机发现的时候，无论指定了何种方式，nmap都会先判断一下目标主机是否和自己处于同一个子网中，如果处于同一个子网，nmap会直接使用ARP协议扫描的方式，而不会使用你指定">
<meta property="og:type" content="article">
<meta property="og:title" content="nmap">
<meta property="og:url" content="https://wakaka6.github.io/2022/04/02/nmap/index.html">
<meta property="og:site_name" content="wakaka">
<meta property="og:description" content="nmap0x01 活跃主机发现技术注意：使用任何扫描工具得到的扫描结果仅供参考  nmap主机发现技术分析  nmap中提供了--packet-trace选项来观察nmap发出了哪些数据包，收到了哪些数据包，由此可知nmap在进行主机发现的时候，无论指定了何种方式，nmap都会先判断一下目标主机是否和自己处于同一个子网中，如果处于同一个子网，nmap会直接使用ARP协议扫描的方式，而不会使用你指定">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://wakaka6.github.io/img/page/3.jpg">
<meta property="article:published_time" content="2022-04-02T14:06:43.000Z">
<meta property="article:modified_time" content="2022-04-02T14:07:48.850Z">
<meta property="article:author" content="wakaka">
<meta property="article:tag" content="nmap">
<meta property="article:tag" content="pentest">
<meta property="article:tag" content="information security">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://wakaka6.github.io/img/page/3.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://wakaka6.github.io/2022/04/02/nmap/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'nmap',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-02 22:07:48'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/page/3.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">wakaka</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">nmap</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-02T14:06:43.000Z" title="发表于 2022-04-02 22:06:43">2022-04-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-02T14:07:48.850Z" title="更新于 2022-04-02 22:07:48">2022-04-02</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="nmap"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><h2 id="0x01-活跃主机发现技术"><a href="#0x01-活跃主机发现技术" class="headerlink" title="0x01 活跃主机发现技术"></a>0x01 活跃主机发现技术</h2><p><em><strong>注意：使用任何扫描工具得到的扫描结果仅供参考</strong></em></p>
<ul>
<li><p>nmap主机发现技术分析</p>
<blockquote>
<p>nmap中提供了<code>--packet-trace</code>选项来观察nmap发出了哪些数据包，收到了哪些数据包，由此可知<br>nmap在进行主机发现的时候，无论指定了何种方式，nmap都会先判断一下目标主机是否和自己处于同一个子网中，如果处于同一个子网，nmap会直接使用ARP协议扫描的方式，而不会使用你指定的扫描方式</p>
</blockquote>
</li>
<li><p>只探测目标主机是否活跃，不进行对于端口扫描</p>
<ul>
<li>使用参数<code>-sn</code><ul>
<li>之前的版本是-sP参数</li>
</ul>
</li>
<li>命令语法：<code>nmap -sn [ 目标 ]</code></li>
</ul>
</li>
</ul>
<h3 id="1-1-基于ARP协议的活跃主机发现技术"><a href="#1-1-基于ARP协议的活跃主机发现技术" class="headerlink" title="1.1 基于ARP协议的活跃主机发现技术"></a>1.1 基于ARP协议的活跃主机发现技术</h3><ul>
<li><h4 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h4><blockquote>
<p>如果想要知道处在同一网段的IP地址为<code>*.*.*.*</code>的主机是否为活跃主机，<br>只需要构建一个ARP请求数据包，并广播出去，如果得到了回应，则说明<br>该主机为活跃主机</p>
</blockquote>
</li>
<li><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote>
<p>准度高<br>因为不遵守ARP协议将无法通信</p>
</blockquote>
</li>
<li><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><blockquote>
<p>不能对不同网段的目标主机进行扫描</p>
</blockquote>
</li>
<li><h4 id="使用参数-PR"><a href="#使用参数-PR" class="headerlink" title="使用参数-PR"></a>使用参数<code>-PR</code></h4><ul>
<li>命令语法：<code>nmap -PR [ 目标 ]</code></li>
</ul>
</li>
</ul>
<h3 id="1-2-基于ICMP协议的活跃主机发现技术"><a href="#1-2-基于ICMP协议的活跃主机发现技术" class="headerlink" title="1.2 基于ICMP协议的活跃主机发现技术"></a>1.2 基于ICMP协议的活跃主机发现技术</h3><blockquote>
<p>ICMP协议中包含了很多方法，但是基于ICMP协议的扫描方式往往也是安全防御的重点，因此<strong>经常得不到准确的结果</strong></p>
</blockquote>
<ul>
<li><h4 id="ICMP的报文的种类"><a href="#ICMP的报文的种类" class="headerlink" title="ICMP的报文的种类"></a>ICMP的报文的种类</h4>  <table>
      <tr>
      <td><b>ICMP 报文的种类</b></td>
      <td><b>类型的值</b></td>
      <td><b>ICMP 报文的类型 </b></td>
      </tr>
      <tr>
      <td rowspan="5" align=center>差错报告报文</td>
      <td align=center>3</td>
      <td>终点不可达</td>
      </tr>
      <tr>
      <td align=center>4</td>
      <td>源抑制</td>
      </tr>
      <tr>
      <td align=center>11</td>
      <td>超时</td>
      </tr>
      <tr>
      <td align=center>12</td>
      <td>参数失灵</td>
      </tr>
      <tr>
      <td align=center>5</td>
      <td>重定向</td>
      </tr>
      <tr bgcolor=#E0FFFF>
      <td rowspan="4" align=center>查询报文</td>
      <td align=center>8或0</td>
      <td>响应请求或应答</td>
      </tr>
      <tr bgcolor=#E0FFFF>
      <td align=center >13或14</td>
      <td>时间戳请求或应答</td>
      </tr>
      <tr bgcolor=#E0FFFF>
      <td align=center>17或18</td>
      <td>地址掩码请求或应答</td>
      </tr>
      <tr>
      <td align=center>10或9</td>
      <td>路由器询问或通告</td>
      </tr>
  </table></li>
<li><h4 id="ICMP活跃主机发现技术主要使用表格中的高亮部分的查询报文"><a href="#ICMP活跃主机发现技术主要使用表格中的高亮部分的查询报文" class="headerlink" title="ICMP活跃主机发现技术主要使用表格中的高亮部分的查询报文"></a>ICMP活跃主机发现技术主要使用表格中的高亮部分的查询报文</h4><ol>
<li><h4 id="响应请求和应答"><a href="#响应请求和应答" class="headerlink" title="响应请求和应答"></a>响应请求和应答</h4><ul>
<li><p>说明：</p>
<blockquote>
<p>用来测试发送与接收两端链路及目标主机TCP/IP协议是否正常，只要收到就是正常<br> ping命令就是利用ICMP的这一种种类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((主机A)) -- 发送ICMP报文 --&gt; B((主机B))</span><br><span class="line">B -- 如果途中没有异常, 则主机B返回ICMP报文 --&gt; A</span><br></pre></td></tr></table></figure>
<p>异常（例如被路由器丢弃、目标不回应ICMP或传输失败）</p>
</blockquote>
</li>
<li><h4 id="参数-PE"><a href="#参数-PE" class="headerlink" title="参数-PE"></a>参数<code>-PE</code></h4><ul>
<li>命令语法：<code>nmap -PE [ 目标 ]</code></li>
<li>namp使用这个参数过程实质上ping是一样的</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="时间戳的请求和应答"><a href="#时间戳的请求和应答" class="headerlink" title="时间戳的请求和应答"></a>时间戳的请求和应答</h4><ul>
<li><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><blockquote>
<p>ICMP时间戳请求允许系统向另一个系统查询当前时间。<br>返回的建议值是自午夜开始计算的毫秒数，即UTC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A((主机A)) -- 发送ICMP时间戳请求 --&gt; B((主机B))</span><br><span class="line">B -- 如果主机B响应请求,说明主机B在线 --&gt; A</span><br></pre></td></tr></table></figure>
<p>数据包内容不重要，重要的是是否收到了回应</p>
</blockquote>
</li>
<li><h4 id="参数-PP"><a href="#参数-PP" class="headerlink" title="参数-PP"></a>参数<code>-PP</code></h4><ul>
<li>命令语法：<code>nmap -PP [ 目标 ]</code></li>
<li>ping方式已经被很多网络所禁止，因此可以利用这个参数来基于ICMP协议的时间戳来发现主机</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="地址掩码的请求和应答（不好用）"><a href="#地址掩码的请求和应答（不好用）" class="headerlink" title="地址掩码的请求和应答（不好用）"></a>地址掩码的请求和应答（不好用）</h4><ul>
<li><p>说明：</p>
<blockquote>
<p>ICMP地址掩码请求由源主机发送，用于<strong>无盘系统</strong>在引导过程种获取自己的子网掩码。<br>虽然这个协议主要用在无盘系统，但是也有一些系统收到这个请求后会返回应答<br><strong>这种方法实际上很少用</strong></p>
</blockquote>
</li>
<li><p>参数<code>-PM</code></p>
<ul>
<li>命令语法：<code>nmap -PM [ 目标 ]</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="1-3-基于TCP协议的活跃主机发现技术"><a href="#1-3-基于TCP协议的活跃主机发现技术" class="headerlink" title="1.3 基于TCP协议的活跃主机发现技术"></a>1.3 基于TCP协议的活跃主机发现技术</h3><ul>
<li><h4 id="TCP协议简介"><a href="#TCP协议简介" class="headerlink" title="TCP协议简介"></a>TCP协议简介</h4><blockquote>
<p>TCP(Transmission Control Protocol，传输控制协议)是一个位于<strong>传输层</strong>的协议。<br>它是一个<strong>面向连接、可靠的、基于字节流</strong>的传输层通信协议。</p>
</blockquote>
</li>
<li><h4 id="nmap使用TCP协议的原理"><a href="#nmap使用TCP协议的原理" class="headerlink" title="nmap使用TCP协议的原理"></a>nmap使用TCP协议的原理</h4><blockquote>
<p>nmap中常用的TCP协议扫描方式有两种，分别是TCP SYN扫描与TCP ACK扫描, 这两种扫描方式其实都是利用<strong>TCP三次握手</strong>实现的。<br><strong>TCP协议中结束连接的方法就是向目标发送一个RST数据包</strong><br><strong>注意：很多服务器的安全机制会屏蔽掉它提供服务以外的端口，向这些端口发包，可能会得不到响应，就不能确定目标是否存活。</strong><br><strong>如果namp向目标发包后没有收到任何应答，nmap将判断目标不在线(哪怕只是目标过滤掉了数据包)</strong></p>
</blockquote>
</li>
<li><h4 id="TCP-SYN扫描"><a href="#TCP-SYN扫描" class="headerlink" title="TCP SYN扫描"></a>TCP SYN扫描</h4><ul>
<li>参数<code>-PS</code><ul>
<li>命令语法：<code>nmap -PS[端口1, 端口2, ···] [目标]</code></li>
</ul>
</li>
<li>说明：<blockquote>
<p>nmap使用<code>-PS</code>选项来向目标主机发送一个设置了SYN标志的数据包，这个数据包的内容部分为空。<br>探测的默认端口为80,也可以在选项后面指定端口,当指定多个端口时，nmap会对这些端口并发的进行测试<br>当目标端口开发, 目标会返回一个SYN/ACK数据包<br>当目标端口是关闭的，目标存活的话就会返回RST数据包<br>故只要<strong>收到目标返回的数据包，就意味着目标存活，反之，目标不在线</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><h4 id="TCP-ACK扫描（不好用，很少得到准确的结果）"><a href="#TCP-ACK扫描（不好用，很少得到准确的结果）" class="headerlink" title="TCP ACK扫描（不好用，很少得到准确的结果）"></a>TCP ACK扫描（不好用，很少得到准确的结果）</h4><ul>
<li>参数<code>-PA</code><ul>
<li> 命令语法<code>nmap -PA[端口1,端口2,···] [目标]</code></li>
<li>不指定端口，默认为80</li>
<li>注意参数<code>-PA</code>和指定端口直接不能有空格，端口直接的逗号也不能有空格</li>
<li>示例：<code>nmap -PA2333,2334 1.1.1.1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-基于UDP协议的活跃主机发现技术"><a href="#1-4-基于UDP协议的活跃主机发现技术" class="headerlink" title="1.4 基于UDP协议的活跃主机发现技术"></a>1.4 基于UDP协议的活跃主机发现技术</h3><ul>
<li><h4 id="UDP协议简介"><a href="#UDP协议简介" class="headerlink" title="UDP协议简介"></a>UDP协议简介</h4><blockquote>
<p>UDP协议也是一个位于传输层的协议。<br>它是一个<strong>非面向连接的、不可靠的</strong>传输层通信协议<br><strong>当一个UDP端口收到一个UDP数据包时，如果它是关闭的，就会给源端发回一个ICMP端口不可达的数据包(type=3、code=3);</strong><br><strong>但是如果它是开放的，就会忽然这个数据包，也就是将它丢弃而不返回任何数据包。</strong></p>
</blockquote>
</li>
<li><h4 id="nmap使用UDP协议的原理"><a href="#nmap使用UDP协议的原理" class="headerlink" title="nmap使用UDP协议的原理"></a>nmap使用UDP协议的原理</h4><blockquote>
<p>namp需要扫描目标主机关闭的端口，与TCP不同；<br>因为只有端口是关闭的，udp协议才会返回ICMP数据包(type=3、code=3)</p>
</blockquote>
</li>
<li><h4 id="使用UDP协议进行主机发现"><a href="#使用UDP协议进行主机发现" class="headerlink" title="使用UDP协议进行主机发现"></a>使用UDP协议进行主机发现</h4><ul>
<li>参数<code>-PU</code><ul>
<li>命令语法<code>nmap -PU[端口1,端口2,···] [目标]</code></li>
<li>不指定端口默认为40125</li>
<li>注意参数<code>-PU</code>和指定端口直接不能有空格</li>
<li>示例：<code>nmap -PU2333,2334 1.1.1.1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-5-基于SCTP协议的活跃主机发现技术"><a href="#1-5-基于SCTP协议的活跃主机发现技术" class="headerlink" title="1.5 基于SCTP协议的活跃主机发现技术"></a>1.5 基于SCTP协议的活跃主机发现技术</h3><ul>
<li><h4 id="SCTP协议解析-支持这种协议的主机并不多"><a href="#SCTP协议解析-支持这种协议的主机并不多" class="headerlink" title="SCTP协议解析(支持这种协议的主机并不多)"></a>SCTP协议解析(支持这种协议的主机并不多)</h4><ul>
<li>SCTP于TCP同属于传输层上的协议。</li>
<li>SCTP协议与TCP完成的任务是相同的</li>
<li>但是两者存在着很大的不同之处：<ol>
<li>TCP协议一般是单地址连接的，而SCTP却可以用于多地址连接</li>
<li>TCP协议是基于字节流，SCTP是基于消息流的</li>
<li>TCP连接的建立是通过3次握手，而SCTP是通过一种4次握手的机制实现的</li>
</ol>
</li>
</ul>
</li>
<li><h4 id="使用SCTP协议进行主机发现"><a href="#使用SCTP协议进行主机发现" class="headerlink" title="使用SCTP协议进行主机发现"></a>使用SCTP协议进行主机发现</h4><ul>
<li>参数<code>-PY</code><ul>
<li>命令语法：<code>nmap -PY[port1,port2,...] [目标]</code></li>
<li>不指定端口默认为80</li>
<li>范例：<code>nmap -sn -PY 1.1.1.1</code><ul>
<li>对1.1.1.1这个主机发送一个SCTP INIT数据包进行SCTP协议类型的扫描</li>
</ul>
</li>
<li><strong>注意：目前支持这个协议的主机并不多，因此这种方法只能作为一种备用手段</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-6-基于IP协议进行主机地址发现"><a href="#1-6-基于IP协议进行主机地址发现" class="headerlink" title="1.6 基于IP协议进行主机地址发现"></a>1.6 基于IP协议进行主机地址发现</h3><ul>
<li><h4 id="IP协议解析"><a href="#IP协议解析" class="headerlink" title="IP协议解析"></a>IP协议解析</h4><blockquote>
<p>IP协议是TCP/IP协议族中的核心协议，也是TCP/IP的载体<br><strong>所有的TCP、UDP、ICMP、IGMP数据都以IP数据包格式传输</strong><br>IP数据包的8-16位用来区分服务，用来标识是哪个协议向IP传送数据；<br>比如：ICMP为1，IGMP为2, TCP为6, UDP为17，GRE为47，ESP为50等。</p>
</blockquote>
</li>
<li><h4 id="使用IP协议进行主机发现"><a href="#使用IP协议进行主机发现" class="headerlink" title="使用IP协议进行主机发现"></a>使用IP协议进行主机发现</h4><blockquote>
<p>nmap中允许向目标主机发送IP数据包来检测目标主机是否活跃，理论上可以使用的协议多达上百个。</p>
</blockquote>
<ul>
<li>参数<code>-PO</code><ul>
<li>命令语法：<code>nmap -PO [协议号1,协议号2,...] [目标]</code></li>
<li>如果不指定协议标识号，nmap默认使用ICMP(1)、IGMP(2)、IP-in-IP(4)三个协议<ul>
<li>即<code>nmap -PO 1.1.1.1</code> 相当于 <code>nmap -PO 1,2,4 1.1.1.1</code></li>
</ul>
</li>
<li>注意：只用<code>-PO</code>参数发出的数据包内容都是空的，这种数据包很容易被检测出来，可以使用参数<code>--data-length</code>来向数据包填入随机数据<ul>
<li>例如：<code>nmap -sn -PO --data-length 25 1.1.1.1</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="1-7-Namp中的DNS选项"><a href="#1-7-Namp中的DNS选项" class="headerlink" title="1.7 Namp中的DNS选项"></a>1.7 Namp中的DNS选项</h3><ul>
<li>对一个网段进行nmap扫描，该网段可能有活跃的主机与非活跃的主机，<strong>如果直接进行扫描，nmap只会对处于活跃状态的主机进行DNS转换，而非活跃的主机将不予处理</strong></li>
<li>如果希望所有目标的IP<strong>无论是否活跃都进行DNS转换</strong>将对应域名列出来<ul>
<li>可以使用参数<code>-R</code><ul>
<li>命令语法：<code>nmap -R [目标IP]</code></li>
</ul>
</li>
</ul>
</li>
<li>如果强制将每个IP都转换为域名，会浪费时间，已知主机的域名，则不需要转换<ul>
<li>用参数<code>-n</code><strong>取消对域名的转换</strong><ul>
<li>命令语法<code>nmap -n [目标IP]</code></li>
</ul>
</li>
</ul>
</li>
<li>如果不想在自己的DNS服务器上留下这次查询的记录，可能需要指定DNS服务器来查询目标<ul>
<li>可以使用参数<code>--dns-servers</code><ul>
<li>命令语法<code>nmap --dns-servers [server1,server2] [目标IP]</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x02-端口扫描技术"><a href="#0x02-端口扫描技术" class="headerlink" title="0x02 端口扫描技术"></a>0x02 端口扫描技术</h2><ul>
<li>在端口扫描时，一般都已经确定目标在线了，所以跳过主机发现阶段<ul>
<li>使用参数<code>-Pn</code>或<code>-P0</code>认为所有目标都是在线的来完全跳过主机发现阶段<ul>
<li>命令语法：<code>nmap -Pn [目标IP]</code></li>
<li>或者：<code>nmap -P0 [目标IP]</code><h3 id="2-1-nmap中对于端口状态的定义"><a href="#2-1-nmap中对于端口状态的定义" class="headerlink" title="2.1 nmap中对于端口状态的定义"></a>2.1 nmap中对于端口状态的定义</h3></li>
</ul>
</li>
</ul>
</li>
<li>nmap中对于端口给出了6种不同状态的描述  <table>
<thead>
<tr>
<th align="center">端口状态</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">open</td>
<td>表明该端口有应用程序接收TCP连接或UDP报文</td>
</tr>
<tr>
<td align="center">closed</td>
<td>这里要注意<code>closed</code>并不意味着端口是关闭的，状态为<code>closed</code>的端口是可访问的，这种端口可以接收nmap的探测报文并做出响应，只是没有应用程序在open上监听。</td>
</tr>
<tr>
<td align="center">filtered</td>
<td>产生这种结果的原因主要是存在目标网络数据包过滤，由于这些设备过滤了探测数据包，导致nmap无法确定目标端口是否开放。这种设备可能是路由器、防火墙、甚至是专门的安全软件。</td>
</tr>
<tr>
<td align="center">unfiltered</td>
<td>这种结果很少见，它表明端口是可以访问的，但是nmap无法判断它是<code>open</code>还是<code>closed</code>的。通常只有在进行ACK扫描时才会出现这种状态。</td>
</tr>
<tr>
<td align="center">open|filtered</td>
<td>无法确定端口是开放的还是被过滤了。开放的端口不响应就是一个例子。</td>
</tr>
<tr>
<td align="center">closed|filtered</td>
<td>无法确定端口是关闭的还是被过滤了。只有在使用idle扫描时才会发生这种情况。</td>
</tr>
</tbody></table>
<h3 id="2-2-UDP端口扫描技术"><a href="#2-2-UDP端口扫描技术" class="headerlink" title="2.2 UDP端口扫描技术"></a>2.2 UDP端口扫描技术</h3></li>
<li>使用UDP扫描时目标的应答与对应端口的状态<table>
<thead>
<tr>
<th>目标主机的应答</th>
<th align="center">目标端口的状态</th>
</tr>
</thead>
<tbody><tr>
<td>从目标端口得到任意UDP的应答</td>
<td align="center">open</td>
</tr>
<tr>
<td>如果目标主机没有给出应答</td>
<td align="center">open|filtered</td>
</tr>
<tr>
<td>ICMP端口不可抵达(type=3, code=3)</td>
<td align="center">closed</td>
</tr>
<tr>
<td>ICMP无法抵达错误(type=3, code=1、2、9、10、13)</td>
<td align="center">filtered</td>
</tr>
</tbody></table>
</li>
<li>要注意UDP扫描速度是相当慢的。使用参数<code>-sU</code>进行UDP端口扫描<ul>
<li>命令语法：<code>nmap -sU [target]</code><h3 id="2-3-TCP端口扫描技术"><a href="#2-3-TCP端口扫描技术" class="headerlink" title="2.3 TCP端口扫描技术"></a>2.3 TCP端口扫描技术</h3></li>
</ul>
</li>
<li><h4 id="SYN扫描"><a href="#SYN扫描" class="headerlink" title="SYN扫描"></a>SYN扫描</h4><ul>
<li>SYN扫描是最为流行的一种扫描方式，也是nmap默认的扫描方式。</li>
<li>SYN扫描速度快，不容易被网络中的安全设备所发现，因为没有完整建立TCP三次握手</li>
<li>SYN扫描需要root或administrator权限</li>
<li>对目标进行SYN扫描时目标主机的应答与对应端口的状态<table>
<thead>
<tr>
<th>目标主机的应答</th>
<th align="center">目标端口的状态</th>
</tr>
</thead>
<tbody><tr>
<td>如果目标主机给出了一个SYN/ACK应答</td>
<td align="center">open</td>
</tr>
<tr>
<td>如果目标主机给出了一个RST应答</td>
<td align="center">closed</td>
</tr>
<tr>
<td>如果目标主机没有给出应答</td>
<td align="center">filtered</td>
</tr>
<tr>
<td>ICMP无法抵达错误(type=3, code=1、2、9、10、13)</td>
<td align="center">filtered</td>
</tr>
</tbody></table>
</li>
<li>使用参数<code>-sS</code>进行SYN端口扫描<ul>
<li>命令语法：<code>nmap -sS [target]</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Connect扫描"><a href="#Connect扫描" class="headerlink" title="Connect扫描"></a>Connect扫描</h4><ul>
<li>这种扫描与SYN扫描很像，但是其建立了完整的TCP三次握手</li>
<li>隐蔽性降低，可能留下访问日志</li>
<li>这种扫描无需root或administrator权限</li>
<li>使用参数<code>-sT</code>进行Connect端口扫描<ul>
<li>命令语法：<code>nmap -sT [target]</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="FIN-扫描"><a href="#FIN-扫描" class="headerlink" title="FIN 扫描"></a>FIN 扫描</h4><ul>
<li>TCP FIN 扫描方法向目标端口发送一个<strong>FIN</strong>数据包。<strong>按照RFC-739的规定，对于所有关闭的端口，目标系统应该放回RST标志</strong></li>
<li>使用参数<code>-sF</code>进行FIN端口扫描<ul>
<li>命令语法：<code>nmap -sF [target]</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="NULL-扫描"><a href="#NULL-扫描" class="headerlink" title="NULL 扫描"></a>NULL 扫描</h4><ul>
<li>TCP NULL 扫描是向目标端口发送一个<strong>不包含任何标志</strong>的数据包。<strong>按照RFC-739规定，对于所有关闭的端口，目标系统应该放回RST标志</strong></li>
<li>使用参数<code>-sN</code>进行NULL端口扫描<ul>
<li>命令语法：<code>nmap -sN [target]</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="Xmas-Tree-扫描"><a href="#Xmas-Tree-扫描" class="headerlink" title="Xmas Tree 扫描"></a>Xmas Tree 扫描</h4><ul>
<li>TCP Xmas Tree 扫描方法是向目标端口发送一个含有<strong>FIN、URG和PUSH标志</strong>的数据包。<strong>按照RFC-739规定，对于所有关闭的端口，目标系统应该放回RST标志</strong></li>
<li>使用参数<code>-sX</code>进行Xmas Tree端口扫描<ul>
<li>命令语法：<code>nmap -sX [target]</code><h3 id="2-4-idle端口扫描技术-僵尸扫描"><a href="#2-4-idle端口扫描技术-僵尸扫描" class="headerlink" title="2.4 idle端口扫描技术(僵尸扫描)"></a>2.4 idle端口扫描技术(僵尸扫描)</h3></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="僵尸扫描优缺点介绍"><a href="#僵尸扫描优缺点介绍" class="headerlink" title="僵尸扫描优缺点介绍"></a>僵尸扫描优缺点介绍</h4><ul>
<li>可以绕开一些网络中的安全机制，如路由器中的访问控制列表技术(ACL)，某些单位的内部网络限制只允许指定IP地址对其内部进行访问</li>
<li>极其隐蔽，需要借助肉鸡来实现</li>
<li>条件苛刻<ul>
<li>肉鸡必须是整数递增的<code>IP ID</code></li>
<li>肉鸡必须空闲，因为大量无关的流量将导致结果极为混乱</li>
</ul>
</li>
<li>速度慢</li>
</ul>
</li>
<li><h4 id="僵尸扫描原理介绍"><a href="#僵尸扫描原理介绍" class="headerlink" title="僵尸扫描原理介绍"></a>僵尸扫描原理介绍</h4><ol>
<li>给肉鸡发送SYN/ACK数据包，检测肉鸡返回的RST数据包的<code>IP ID值</code>并记录下来。</li>
<li>在本机上伪造一个源地址为肉鸡的数据包，并将数据包发送给目标主机端口，根据目标端口状态的不同，目标主机可能导致肉鸡的<code>IP ID值</code>增加。<ul>
<li>如果目标主机端口开放，将向肉鸡返回SYN/ACK数据包，于是肉鸡将向目标返回一个RST数据包，导致肉鸡的<code>IP ID值</code>增加一;</li>
<li>如果目标主机端口关闭，将向肉鸡返回RST数据包，肉鸡收到后将不做响应，<code>IP ID值</code>不变。</li>
</ul>
</li>
<li>再次给肉鸡发送SYN/ACK数据包,检测肉鸡返回的RST数据包的<code>IP ID值</code>与步骤一的<code>IP ID值</code>进行<strong>比较</strong>。<ul>
<li>如果增加一，则肉鸡在这期间没有向外发送数据包，说明目标端口是关闭的;</li>
<li>如果增加二，则肉鸡在这期间向外发送了数据包，说明目标端口是开放的。</li>
</ul>
</li>
</ol>
</li>
<li><h4 id="nmap中僵尸扫描的使用方法"><a href="#nmap中僵尸扫描的使用方法" class="headerlink" title="nmap中僵尸扫描的使用方法"></a>nmap中僵尸扫描的使用方法</h4><ol>
<li>发现僵尸机<ul>
<li>法一：对一台主机进行扫描时，执行一个端口扫描以及系统检测，启动详细模式(<code>-v</code>)，nmap就会检测操作系统<code>IP ID</code>增长的方法，如果返回值为<code>IP ID Sequence Generation: Incremental</code>，说明<code>IP ID</code>递增，但还需要确定一下，因为<strong>很多系统其实为每一个通信都开启了一个</strong><code>IP ID</code>，另外，如果这台主机和外界进行大量的通信，这种方法也不适用。</li>
<li>法二：<strong>使用ipidseq NSE脚本(推荐这种)</strong><ul>
<li>命令语法：<code>nmap -p[端口] [肉鸡IP] --script=ipidseq.nse</code></li>
</ul>
</li>
</ul>
</li>
<li>利用僵尸机对目标进行扫描<ul>
<li>利用参数<code>-sI</code>指定肉鸡IP<ul>
<li>命令语法：<code>nmap -sI [肉鸡IP] -p[端口] [target]</code></li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="2-5-指定扫描的端口"><a href="#2-5-指定扫描的端口" class="headerlink" title="2.5 指定扫描的端口"></a>2.5 指定扫描的端口</h3><ul>
<li><h4 id="扫描常见的100个端口"><a href="#扫描常见的100个端口" class="headerlink" title="扫描常见的100个端口"></a>扫描常见的100个端口</h4><ul>
<li>命令语法：<code>nmap -F [target]</code></li>
</ul>
</li>
<li><h4 id="扫描常用的个端口"><a href="#扫描常用的个端口" class="headerlink" title="扫描常用的个端口"></a>扫描常用的个端口</h4><ul>
<li>命令语法：<code>nmap --top-ports [number] [target]</code></li>
<li>范例：对目标10个常见端口进行扫描<ul>
<li><code>nmap --top-ports 10 1.1.1.1</code></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="指定某一端口"><a href="#指定某一端口" class="headerlink" title="指定某一端口"></a>指定某一端口</h4><ul>
<li>命令语法：<code>nmap -p [port] [target]</code></li>
</ul>
</li>
<li><h4 id="使用名字来指定某一端口"><a href="#使用名字来指定某一端口" class="headerlink" title="使用名字来指定某一端口"></a>使用名字来指定某一端口</h4><ul>
<li>命令语法：<code>nmap -p [port name(s)] [target]</code></li>
<li>范例：<code>nmap -p smtp,http 1.1.1.1</code></li>
</ul>
</li>
<li><h4 id="使用协议来指定某一端口"><a href="#使用协议来指定某一端口" class="headerlink" title="使用协议来指定某一端口"></a>使用协议来指定某一端口</h4><ul>
<li>命令语法：<code>nmap -p U:[UDP ports],T:[TCP ports] [target]</code></li>
<li>范例：<code>nmap -p U:53,T:25 1.1.1.1</code></li>
</ul>
</li>
<li><h4 id="扫描所有端口"><a href="#扫描所有端口" class="headerlink" title="扫描所有端口"></a>扫描所有端口</h4><ul>
<li>命令语法：<code>nmap -p- [target]</code></li>
<li>或者 <code>nmap -p* [target]</code></li>
<li>范例：<code>nmap -p- 1.1.1.1</code></li>
<li>这种扫描方法销毁资源很大，慎用</li>
</ul>
</li>
</ul>
<h2 id="0x03-远程操作系统与服务检测技术"><a href="#0x03-远程操作系统与服务检测技术" class="headerlink" title="0x03 远程操作系统与服务检测技术"></a>0x03 远程操作系统与服务检测技术</h2><h3 id="3-1-远程操作系统检测简介"><a href="#3-1-远程操作系统检测简介" class="headerlink" title="3.1 远程操作系统检测简介"></a>3.1 远程操作系统检测简介</h3><blockquote>
<p>nmap进行识别的探针和响应对应的关系保存在<code>nmap-os-db</code>文件中。nmap会根据对目标响应的特征来与<code>nmap-os-db</code>文件做对比识别对应指纹<br><strong>nmap在探测时会验证如下参数：</strong></p>
<ul>
<li>供应商的名字：微软、SUN、Cisco等</li>
<li>操作系统：Windows、Linux、Mac OS X等</li>
<li>操作系统的版本：Windows XP、Centos7等</li>
<li>当前设备的类型：比如通用计算机、打印服务器、媒体播放器、路由器、WAP或电力装置等</li>
</ul>
</blockquote>
<ul>
<li><h4 id="使用参数-O通过端口扫描来完成对操作系统的扫描"><a href="#使用参数-O通过端口扫描来完成对操作系统的扫描" class="headerlink" title="使用参数-O通过端口扫描来完成对操作系统的扫描"></a>使用参数<code>-O</code>通过端口扫描来完成对操作系统的扫描</h4><ul>
<li>命令语法：<code>nmap -O [target]</code></li>
<li>这个命令将会使用nmap默认SYN扫描方式来完成端口探测，不过也可以结合其他的检测技术来指定扫描方式。</li>
<li>启用参数<code>-O</code>或<code>-A</code>后扫描目标操作系统的可选项<table>
<thead>
<tr>
<th align="center">选项</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">–osscan-limit</td>
<td>只对满足”<strong>同时具有<code>open</code>和<code>closed</code>状态的端口</strong>“条件的主机进行操作系统检测</td>
</tr>
<tr>
<td align="center">–osscan-guess</td>
<td><strong>猜测</strong> 最接近目标的匹配操作系统类型</td>
</tr>
<tr>
<td align="center">–max-retries</td>
<td>对操作系统检测尝试的次数，默认为5</td>
</tr>
</tbody></table>
</li>
<li>范例：<code>nmap -P0 -sT -F -O --osscan-limit 1.1.1.1</code></li>
</ul>
</li>
</ul>
<h3 id="3-2-操作系统指纹简介"><a href="#3-2-操作系统指纹简介" class="headerlink" title="3.2 操作系统指纹简介"></a>3.2 操作系统指纹简介</h3><blockquote>
<p><strong>远程判断目标计算机操作系统的方法一般可分成两类：</strong></p>
<ul>
<li><strong>被动式方法</strong>：并不祥目标系统发送任何数据包，而是通过各种抓包工具来收集流经网络的数据报文，再从这些报文中得到目标操作系统的信息。</li>
<li><strong>主动式方法</strong>：指客户端主动向远程服务器发送信息，远程服务器一般要对这些信息做出反应，回复一些信息，发送者对这些返回的信息进行分析，就有可能得知远程主机的操作系统类型。这些信息可以是通过正常的网络程序如Telnet、FTP等与主机交互的信息，也可以是一些经过精心构造、正常的或残缺的数据报文。</li>
</ul>
<p><strong>nmap并不使用被动式的方法。nmap中的主动式方法采用多达15个指针的操作系统指纹扫描包</strong></p>
</blockquote>
<ul>
<li><h4 id="指纹扫描作为管理工具"><a href="#指纹扫描作为管理工具" class="headerlink" title="指纹扫描作为管理工具"></a>指纹扫描作为管理工具</h4><ul>
<li>nmap也可以作为一个网络管理器。</li>
<li>对一个子网执行如下命令<ul>
<li><code>nmap --O [ip subnet]</code></li>
<li>或者<code>nmap -sV -F --fuzzy --ossan-guess [target ip]</code></li>
</ul>
</li>
<li>这种情况下，nmap会输出目标系统的TCP/IP指纹文件，并给出各个系统类型的可能性，输出结果可查看官方文档进行理解</li>
</ul>
</li>
</ul>
<h3 id="3-3-服务发现"><a href="#3-3-服务发现" class="headerlink" title="3.3 服务发现"></a>3.3 服务发现</h3><blockquote>
<p><strong>nmap进行服务发现的过程：</strong></p>
<ol>
<li>首先进行端口扫描，默认情况下使用SYN扫描，此时会对常用端口的服务进行猜测</li>
<li>其次进行服务识别，发送探针报文，得到确认值，确认服务</li>
<li>最后进行版本识别，发送探针报文，得到返回的报文信息，分析得出服务的版本</li>
</ol>
<p>nmap会将版本探测结果与<code>nmap-service-probes</code>数据库中内容进行比较，如果匹配成功，将确定该端口的服务</p>
</blockquote>
<ul>
<li><h4 id="可以使用以下参数打开和控制版本检测"><a href="#可以使用以下参数打开和控制版本检测" class="headerlink" title="可以使用以下参数打开和控制版本检测"></a>可以使用以下参数打开和控制版本检测</h4><ul>
<li><strong>使用参数<code>-sV</code>开启版本探测</strong><ul>
<li>命令语法：<code>nmap -sV [target]</code></li>
<li>也可以使用参数<code>-A</code>同时开启操作系统检测服务发现<ul>
<li><code>-A</code>参数相当于 <code>-O -sV</code></li>
</ul>
</li>
<li><em><strong>只有开启这个参数后面的参数才能生效</strong></em></li>
</ul>
</li>
<li><strong>使用参数<code>--allports</code>不为版本探测排除任何端口</strong><ul>
<li>命令语法：<code>nmap -sV --allports [target]</code></li>
<li>说明：<ul>
<li>通常，nmap在进行版本探测时不会对目标的全部端口进行探测，而会跳过一些端口。</li>
<li>例如对TCP 9100端口时，如果目标恰好是一台打印机，那么这台打印机可能会将数据全部打印出来。</li>
<li>如果确实有必要的话，可以使用<code>--allprots</code>来扫描所有端口。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用参数<code>--version-intensity &lt;intensity&gt;</code>设置版本扫描强度</strong><ul>
<li>命令语法：<code>nmap -sV --version-intensity &lt;intensity&gt; [target]</code></li>
<li>说明：<ul>
<li>当进行版本扫描时，nmap发送的一系列报文都被赋予一个<code>1到9</code>之间的值。</li>
<li>这里的强度水平说明了应该使用哪些探测报文。数值越高，服务越有可能被正确的识别。但是，高强度的扫描花更多时间。</li>
<li>强度值必须在<code>0-9</code>之间，默认是7。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用参数<code>--version-light</code>打开轻量级模式</strong><ul>
<li>说明：<ul>
<li><code>--version-light</code>相当于<code>--version-intensity 2</code></li>
<li>这种轻量级模式加快了扫描速度，降低了对服务的扫描成功率</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用参数<code>--version-all</code>尝试每个都探测</strong><ul>
<li>说明：<ul>
<li><code>--version-light</code>相当于<code>--version-intensity 9</code></li>
<li>保证对每个端口尝试所有的探测报文。</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用参数<code>--version-trace</code>进行跟踪版本扫描活动</strong><ul>
<li>说明：<ul>
<li>这将使nmap打印出关于正在进行扫描的详细调试信息。</li>
<li>它的输出结果是参数<code>--packet-trace</code>的子集</li>
</ul>
</li>
</ul>
</li>
<li><strong>使用参数<code>-sR</code>进行RPC(远程过程调用)扫描</strong><ul>
<li>RPC：调用远程计算机上的服务，就像调用本地服务一样</li>
<li>命令语法：<code>nmap -sV -sR [target]</code></li>
<li>说明：<ul>
<li>这种方法和许多端口扫描方法联合使用。</li>
<li>它对所有被发现开放的TCP/UDP端口执行SunRPC程序NULL命令，试图确定它们是否RPC端口，如果是，可以确定是什么程序和版本号。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x04-nmap伪装技术"><a href="#0x04-nmap伪装技术" class="headerlink" title="0x04 nmap伪装技术"></a>0x04 nmap伪装技术</h2><h3 id="4-1-报文分段"><a href="#4-1-报文分段" class="headerlink" title="4.1 报文分段"></a>4.1 报文分段</h3><ul>
<li><h4 id="使用参数-f对nmap发送的探测数据包进行分段"><a href="#使用参数-f对nmap发送的探测数据包进行分段" class="headerlink" title="使用参数-f对nmap发送的探测数据包进行分段"></a>使用参数<code>-f</code>对nmap发送的探测数据包进行分段</h4><ul>
<li>命令语法：<code>nmap -f [target]</code></li>
<li>说明：<ul>
<li>使用这个参数将原来的数据包分成几个部分，将使IDS对数据包检测时变得更困难。</li>
<li>需要谨慎使用该参数，一些老旧的系统在处理分段的包时经常会出响死机的情况。</li>
<li>这个功能可能在Windows下无法正常工作。</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="使用参数-mtu-来指定MTU"><a href="#使用参数-mtu-来指定MTU" class="headerlink" title="使用参数--mtu 来指定MTU"></a>使用参数<code>--mtu</code> 来指定MTU</h4><blockquote>
<p>MTU(最大传输单元)是指一种通信协议的某一层上面所能通过的最大数据包的大小(以字节为单位)。nmap可以使用<code>--mut</code>来指定MTU的大小，但是<strong>这里MTU的值必须为8的整数倍</strong></p>
</blockquote>
<ul>
<li>命令语法：<code>nmap --mtu [target]</code></li>
<li>范例：<code>nmap --mtu 8 1.1.1.1</code></li>
</ul>
</li>
<li><h4 id="使用参数-D-lt-decoy1-decoy2-ME-gt-进行诱饵主机隐蔽扫描"><a href="#使用参数-D-lt-decoy1-decoy2-ME-gt-进行诱饵主机隐蔽扫描" class="headerlink" title="使用参数-D &lt;decoy1[, decoy2][, ME], ...&gt;进行诱饵主机隐蔽扫描"></a>使用参数<code>-D &lt;decoy1[, decoy2][, ME], ...&gt;</code>进行诱饵主机隐蔽扫描</h4><blockquote>
<p>通常在对目标进行扫描时可能会被发现。nmap支持使用诱饵主机来隐藏自身的IP</p>
</blockquote>
<ul>
<li>命令语法：<code>nmap -D &lt;decoy1[, decoy2][, ME], ...&gt; [target]</code></li>
<li>范例：<code>nmap -D RND:10 1.1.1.1</code></li>
<li>说明：<ul>
<li>使用逗号分隔每个诱饵IP地址，也可以使用自己的真实IP作为诱饵，自己的IP可以使用ME选项。</li>
<li>如果在第6个位置或更后的位置使用ME选项，一些常用的端口扫描检测器就不会报告这个真实IP。</li>
<li>如果不使用ME选项，nmap将真实IP放在一个随机的位置。</li>
<li>注意；<strong>作为诱饵的主机必须处于工作状态</strong>，否则这次扫描就成了SYN洪水攻击</li>
<li>在发现阶段或端口扫描以及远程操作系统检测阶段可以用诱饵主机选项，<strong>但是在进行版本检测(-sV)或TCP连接扫描时(-sT)，诱饵主机选项无效。</strong></li>
</ul>
</li>
</ul>
</li>
<li><h4 id="使用参数-source-port-lt-portnumber-gt-或-g-lt-portnumber-gt-进行源端口欺骗"><a href="#使用参数-source-port-lt-portnumber-gt-或-g-lt-portnumber-gt-进行源端口欺骗" class="headerlink" title="使用参数--source-port &lt;portnumber&gt;或-g &lt;portnumber&gt;进行源端口欺骗"></a>使用参数<code>--source-port &lt;portnumber&gt;</code>或<code>-g &lt;portnumber&gt;</code>进行源端口欺骗</h4><blockquote>
<p>网络安全控制中有一种访问控制列表技术，这种技术主要是依靠IP地址和端口来对数据包进行限制，例如有时需要保证DNS和FTP协议正常工作，很多新手管理员会将来自53端口(DNS)和20端口(FTP)的数据放入网络，导致攻击者可以构造恶意的流量来利用这些端口。</p>
</blockquote>
<ul>
<li>命令语法：<code>nmap -g &lt;portnumber&gt; [target]</code></li>
<li>或者：<code>nmap --source-port &lt;portnumber&gt; [target]</code></li>
<li>范例：<code>nmap -g 88 1.1.1.1</code></li>
<li>说明：只要有一个被目标检测机制遗忘的端口，nmap就可以利用这个选项来伪造源端口发送数据，大部分TCP/UDP扫描都完全支持这些选项。</li>
</ul>
</li>
<li><h4 id="使用参数data-length-lt-number-gt-来在发送报文时附加随机数据"><a href="#使用参数data-length-lt-number-gt-来在发送报文时附加随机数据" class="headerlink" title="使用参数data-length &lt;number&gt;来在发送报文时附加随机数据"></a>使用参数<code>data-length &lt;number&gt;</code>来在发送报文时附加随机数据</h4><blockquote>
<p>默认情况下，nmap发送的报文中只有头部内容部分是空的，因此TCP数据包的大小只有40字节，而ICMP ECHO请求只有28字节。这种内容为空的报文很容易被IDS发现，所以可以使用该参数来增加内容。</p>
</blockquote>
<ul>
<li>命令语法：<code>nmap --data-length &lt;number&gt; [target]</code></li>
<li>范例：<code>nmap --data-length 25 1.1.1.1</code></li>
<li>说明：这个选项会让大部分ping和端口扫描变慢，但是影响不大。</li>
</ul>
</li>
<li><h4 id="使用参数-ttl-lt-value-gt-来设置IP-time-to-live域"><a href="#使用参数-ttl-lt-value-gt-来设置IP-time-to-live域" class="headerlink" title="使用参数--ttl &lt;value&gt;来设置IP time-to-live域"></a>使用参数<code>--ttl &lt;value&gt;</code>来设置IP time-to-live域</h4><ul>
<li>命令语法：<code>nmap --ttl &lt;value&gt; [target]</code></li>
<li>范例：<code>nmap --ttl 30 1.1.1.1</code></li>
</ul>
</li>
<li><h4 id="使用参数-spoof-mac-lt-mac-address-prefix-of-vendor-name-gt-进行MAC地址欺骗"><a href="#使用参数-spoof-mac-lt-mac-address-prefix-of-vendor-name-gt-进行MAC地址欺骗" class="headerlink" title="使用参数--spoof-mac &lt;mac address, prefix, of vendor name&gt;进行MAC地址欺骗"></a>使用参数<code>--spoof-mac &lt;mac address, prefix, of vendor name&gt;</code>进行MAC地址欺骗</h4><blockquote>
<p>通过这个选项可以人为指定nmap在进行扫描工作时发送以太网帧MAC地址。<br>这个选项隐含地使用了<code>--send-eth</code>选项，这样才是真正的以太网包。</p>
</blockquote>
<ul>
<li>命令语法：<code>nmap --spoof-mac &lt;mac address, prefix, of vendor name&gt; [target]</code></li>
<li>范例：<ul>
<li><code>nmap --spoof-mac 0 1.1.1.1</code></li>
<li><code>nmap -spoof-mac Apple 1.1.1.1</code></li>
<li><code>nmap -spoof-mac 01:02:03:04:05:06 1.1.1.1</code></li>
<li><code>nmap -spoof-mac 0020F2 1.1.1.1</code></li>
</ul>
</li>
<li>说明：<ul>
<li>如果使用字符串”0”,nmap选择一个完全随机的MAC地址</li>
<li>如果给定的字符是使用分号分隔的十六进制数字，nmap将使用这个地址。</li>
<li>如果是小于12的十六进制数字，nmap将会随机填充剩下的字节。</li>
<li>如果参数不是0或十六进制数字，nmap将通过<code>nmap-mac-prefixes</code>查找厂商的名称(区分大小写)，如果找到匹配，nmap将使用厂商的OUI(3字节前缀)，然后随机填充剩下的3字节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x05-nmap的格式化输出"><a href="#0x05-nmap的格式化输出" class="headerlink" title="0x05 nmap的格式化输出"></a>0x05 nmap的格式化输出</h2><p>…</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wakaka</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wakaka6.github.io/2022/04/02/nmap/">https://wakaka6.github.io/2022/04/02/nmap/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wakaka6.github.io" target="_blank">wakaka</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/nmap/">nmap</a><a class="post-meta__tags" href="/tags/pentest/">pentest</a><a class="post-meta__tags" href="/tags/information-security/">information security</a></div><div class="post_share"><div class="social-share" data-image="/img/page/3.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/14/go-compile-envirtional-variable/"><img class="prev-cover" src="/img/page/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">go编译相关环境变量</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/17/py-decorator/"><img class="next-cover" src="/img/page/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">python装饰器详解</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://avatars.githubusercontent.com/u/48764488" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">wakaka</div><div class="author-info__description">一个linux爱好者</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/wakaka6"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/wakaka6" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:wakaka6@github.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">Hello World.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#nmap"><span class="toc-number">1.</span> <span class="toc-text">nmap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#0x01-%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.</span> <span class="toc-text">0x01 活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%9F%BA%E4%BA%8EARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 基于ARP协议的活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">缺点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-PR"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">使用参数-PR</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E4%BA%8EICMP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 基于ICMP协议的活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E7%9A%84%E6%8A%A5%E6%96%87%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">ICMP的报文的种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ICMP%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF%E4%B8%BB%E8%A6%81%E4%BD%BF%E7%94%A8%E8%A1%A8%E6%A0%BC%E4%B8%AD%E7%9A%84%E9%AB%98%E4%BA%AE%E9%83%A8%E5%88%86%E7%9A%84%E6%9F%A5%E8%AF%A2%E6%8A%A5%E6%96%87"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">ICMP活跃主机发现技术主要使用表格中的高亮部分的查询报文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E8%AF%B7%E6%B1%82%E5%92%8C%E5%BA%94%E7%AD%94"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">响应请求和应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-PE"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">参数-PE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%BA%94%E7%AD%94"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">时间戳的请求和应答</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">说明：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0-PP"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">参数-PP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E6%8E%A9%E7%A0%81%E7%9A%84%E8%AF%B7%E6%B1%82%E5%92%8C%E5%BA%94%E7%AD%94%EF%BC%88%E4%B8%8D%E5%A5%BD%E7%94%A8%EF%BC%89"><span class="toc-number">1.1.2.8.</span> <span class="toc-text">地址掩码的请求和应答（不好用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 基于TCP协议的活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">TCP协议简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nmap%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">nmap使用TCP协议的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-SYN%E6%89%AB%E6%8F%8F"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">TCP SYN扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP-ACK%E6%89%AB%E6%8F%8F%EF%BC%88%E4%B8%8D%E5%A5%BD%E7%94%A8%EF%BC%8C%E5%BE%88%E5%B0%91%E5%BE%97%E5%88%B0%E5%87%86%E7%A1%AE%E7%9A%84%E7%BB%93%E6%9E%9C%EF%BC%89"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">TCP ACK扫描（不好用，很少得到准确的结果）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%9F%BA%E4%BA%8EUDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 基于UDP协议的活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">UDP协议简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nmap%E4%BD%BF%E7%94%A8UDP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">nmap使用UDP协议的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8UDP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">使用UDP协议进行主机发现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%9F%BA%E4%BA%8ESCTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E6%B4%BB%E8%B7%83%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0%E6%8A%80%E6%9C%AF"><span class="toc-number">1.1.5.</span> <span class="toc-text">1.5 基于SCTP协议的活跃主机发现技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SCTP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90-%E6%94%AF%E6%8C%81%E8%BF%99%E7%A7%8D%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%BB%E6%9C%BA%E5%B9%B6%E4%B8%8D%E5%A4%9A"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">SCTP协议解析(支持这种协议的主机并不多)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8SCTP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">使用SCTP协议进行主机发现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E5%9F%BA%E4%BA%8EIP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%9C%B0%E5%9D%80%E5%8F%91%E7%8E%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">1.6 基于IP协议进行主机地址发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IP%E5%8D%8F%E8%AE%AE%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">IP协议解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8IP%E5%8D%8F%E8%AE%AE%E8%BF%9B%E8%A1%8C%E4%B8%BB%E6%9C%BA%E5%8F%91%E7%8E%B0"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">使用IP协议进行主机发现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-Namp%E4%B8%AD%E7%9A%84DNS%E9%80%89%E9%A1%B9"><span class="toc-number">1.1.7.</span> <span class="toc-text">1.7 Namp中的DNS选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x02-%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.</span> <span class="toc-text">0x02 端口扫描技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-nmap%E4%B8%AD%E5%AF%B9%E4%BA%8E%E7%AB%AF%E5%8F%A3%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 nmap中对于端口状态的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-UDP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 UDP端口扫描技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-TCP%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 TCP端口扫描技术</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SYN%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">SYN扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Connect%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Connect扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FIN-%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">FIN 扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NULL-%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">NULL 扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Xmas-Tree-%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">Xmas Tree 扫描</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-idle%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%8A%80%E6%9C%AF-%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">2.4 idle端口扫描技术(僵尸扫描)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F%E4%BC%98%E7%BC%BA%E7%82%B9%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">僵尸扫描优缺点介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">僵尸扫描原理介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nmap%E4%B8%AD%E5%83%B5%E5%B0%B8%E6%89%AB%E6%8F%8F%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">nmap中僵尸扫描的使用方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%8C%87%E5%AE%9A%E6%89%AB%E6%8F%8F%E7%9A%84%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.</span> <span class="toc-text">2.5 指定扫描的端口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%B8%B8%E8%A7%81%E7%9A%84100%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">扫描常见的100个端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%AA%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">扫描常用的个端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%9F%90%E4%B8%80%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.3.</span> <span class="toc-text">指定某一端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%90%8D%E5%AD%97%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%9F%90%E4%B8%80%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.4.</span> <span class="toc-text">使用名字来指定某一端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8D%8F%E8%AE%AE%E6%9D%A5%E6%8C%87%E5%AE%9A%E6%9F%90%E4%B8%80%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.5.</span> <span class="toc-text">使用协议来指定某一端口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E6%89%80%E6%9C%89%E7%AB%AF%E5%8F%A3"><span class="toc-number">1.2.5.6.</span> <span class="toc-text">扫描所有端口</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x03-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%A3%80%E6%B5%8B%E6%8A%80%E6%9C%AF"><span class="toc-number">1.3.</span> <span class="toc-text">0x03 远程操作系统与服务检测技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%B5%8B%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 远程操作系统检测简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-O%E9%80%9A%E8%BF%87%E7%AB%AF%E5%8F%A3%E6%89%AB%E6%8F%8F%E6%9D%A5%E5%AE%8C%E6%88%90%E5%AF%B9%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%89%AB%E6%8F%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">使用参数-O通过端口扫描来完成对操作系统的扫描</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%8C%87%E7%BA%B9%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 操作系统指纹简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E7%BA%B9%E6%89%AB%E6%8F%8F%E4%BD%9C%E4%B8%BA%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">指纹扫描作为管理工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 服务发现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%A5%E4%B8%8B%E5%8F%82%E6%95%B0%E6%89%93%E5%BC%80%E5%92%8C%E6%8E%A7%E5%88%B6%E7%89%88%E6%9C%AC%E6%A3%80%E6%B5%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">可以使用以下参数打开和控制版本检测</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x04-nmap%E4%BC%AA%E8%A3%85%E6%8A%80%E6%9C%AF"><span class="toc-number">1.4.</span> <span class="toc-text">0x04 nmap伪装技术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%8A%A5%E6%96%87%E5%88%86%E6%AE%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 报文分段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-f%E5%AF%B9nmap%E5%8F%91%E9%80%81%E7%9A%84%E6%8E%A2%E6%B5%8B%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%9B%E8%A1%8C%E5%88%86%E6%AE%B5"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">使用参数-f对nmap发送的探测数据包进行分段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-mtu-%E6%9D%A5%E6%8C%87%E5%AE%9AMTU"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">使用参数--mtu 来指定MTU</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-D-lt-decoy1-decoy2-ME-gt-%E8%BF%9B%E8%A1%8C%E8%AF%B1%E9%A5%B5%E4%B8%BB%E6%9C%BA%E9%9A%90%E8%94%BD%E6%89%AB%E6%8F%8F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">使用参数-D &lt;decoy1[, decoy2][, ME], ...&gt;进行诱饵主机隐蔽扫描</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-source-port-lt-portnumber-gt-%E6%88%96-g-lt-portnumber-gt-%E8%BF%9B%E8%A1%8C%E6%BA%90%E7%AB%AF%E5%8F%A3%E6%AC%BA%E9%AA%97"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">使用参数--source-port &lt;portnumber&gt;或-g &lt;portnumber&gt;进行源端口欺骗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0data-length-lt-number-gt-%E6%9D%A5%E5%9C%A8%E5%8F%91%E9%80%81%E6%8A%A5%E6%96%87%E6%97%B6%E9%99%84%E5%8A%A0%E9%9A%8F%E6%9C%BA%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">使用参数data-length &lt;number&gt;来在发送报文时附加随机数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-ttl-lt-value-gt-%E6%9D%A5%E8%AE%BE%E7%BD%AEIP-time-to-live%E5%9F%9F"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">使用参数--ttl &lt;value&gt;来设置IP time-to-live域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%82%E6%95%B0-spoof-mac-lt-mac-address-prefix-of-vendor-name-gt-%E8%BF%9B%E8%A1%8CMAC%E5%9C%B0%E5%9D%80%E6%AC%BA%E9%AA%97"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">使用参数--spoof-mac &lt;mac address, prefix, of vendor name&gt;进行MAC地址欺骗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#0x05-nmap%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-number">1.5.</span> <span class="toc-text">0x05 nmap的格式化输出</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/21/go-generic/" title="golang泛型机制"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="golang泛型机制"/></a><div class="content"><a class="title" href="/2022/04/21/go-generic/" title="golang泛型机制">golang泛型机制</a><time datetime="2022-04-21T13:41:59.000Z" title="发表于 2022-04-21 21:41:59">2022-04-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="go编译相关环境变量"/></a><div class="content"><a class="title" href="/2022/04/14/go-compile-envirtional-variable/" title="go编译相关环境变量">go编译相关环境变量</a><time datetime="2022-04-14T10:04:18.000Z" title="发表于 2022-04-14 18:04:18">2022-04-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/02/nmap/" title="nmap"><img src="/img/page/3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="nmap"/></a><div class="content"><a class="title" href="/2022/04/02/nmap/" title="nmap">nmap</a><time datetime="2022-04-02T14:06:43.000Z" title="发表于 2022-04-02 22:06:43">2022-04-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/py-decorator/" title="python装饰器详解"><img src="/img/page/1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="python装饰器详解"/></a><div class="content"><a class="title" href="/2022/01/17/py-decorator/" title="python装饰器详解">python装饰器详解</a><time datetime="2022-01-17T12:49:06.000Z" title="发表于 2022-01-17 20:49:06">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/15/signal/" title="linux信号总结"><img src="/img/page/2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux信号总结"/></a><div class="content"><a class="title" href="/2022/01/15/signal/" title="linux信号总结">linux信号总结</a><time datetime="2022-01-14T18:52:59.000Z" title="发表于 2022-01-15 02:52:59">2022-01-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By wakaka</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>